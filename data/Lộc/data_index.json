{"ten_noi_dung": "Con trỏ và mảng trong C++", "ten_muc": "Mối quan hệ giữa con trỏ và mảng", "noi_dung": "Con trỏ và mảng trong C++ có mối liên hệ chặt chẽ với nhau. Thực tế, con trỏ và mảng có thể thay thế cho nhau trong một số trường hợp. Ví dụ, một con trỏ mà trỏ tới phần đầu của mảng có thể truy cập mảng đó bởi sử dụng: con trỏ số học hoặc chỉ số của mảng.\nVí dụ:\n|code|\nKết quả:\n|code|\nTuy nhiên, con trỏ và mảng không hoàn toàn thay thế được cho nhau. Ví dụ:\n|code|\nViệc áp dụng toán tử con trỏ * tới biến mảng arr là hợp lệ, nhưng nó không hợp lệ khi sửa đổi giá trị biến arr. Lý do là biến mảng arr là một hằng số con trỏ trỏ tới phần đầu mảng.\nBởi vì, một tên mảng tạo một hằng con trỏ, nó có thể vẫn được sử dụng trong các biểu thức con trỏ, miễn là nó không bị sửa đổi. Ví dụ sau là một lệnh hợp lệ mà gán arr[2] giá trị 100.\n|code|\nLệnh trên là hợp lệ và sẽ biên dịch thành công vì arr không bị thay đổi.\n", "media": [], "code": [{"": "\n#include <iostream>\n\nusing namespace std;\nconst int MAX = 3;\n\nint main() {\n    int  arr[MAX] = {10, 20, 30};\n    int  *contro;\n\n    // contro tro toi mang\n    contro = arr; // arr dai dien cho gia tri dau tien cua mang arr\n    for (int i = 0; i < MAX; i++) {\n        cout << \"Dia chi cua arr[\" << i << \"] = \";\n        cout << contro << endl;\n\n        cout << \"Gia tri cua arr[\" << i << \"] = \";\n        cout << *contro << endl;\n\n        // tro toi vi tri tiep theo\n        contro++;\n   }\n   return 0;\n}\n"}, {"": "\nDia chi cua arr[0] = 0x6ffe30\nGia tri cua arr[0] = 10\nDia chi cua arr[1] = 0x6ffe34\nGia tri cua arr[1] = 20\nDia chi cua arr[2] = 0x6ffe38\nGia tri cua arr[2] = 30\n"}, {"": "\n#include \n \nusing namespace std;\nconst int MAX = 3;\n \nint main() {\n    int  arr[MAX] = {10, 20, 30};\n \n    for (int i = 0; i < MAX; i++) {\n        *arr = i;    // cu phap nay la dung.\n        arr++;       // cu phap nay la sai.\n        cout << arr[i];\n   }\n   return 0;\n}\n"}, {"": "\n*(arr + 2) = 100;\n"}], "table": []}{"ten_noi_dung": "Con trỏ và mảng trong C++", "ten_muc": "Sự khác nhau giữa con trỏ và mảng trong C++", "noi_dung": "Việc sao chép 1 số lượng lớn các phần tử sẽ gây tốn rất nhiều vùng nhớ và giảm hiệu suất.\nVì vậy, khi truyền một mảng cho một hàm, mảng sẽ được chuyển đổi ngầm định thành một con trỏ trỏ đến mảng, và con trỏ được truyền vào hàm:\n|code|\nOutput:\n|code|\nLưu ý rằng điều này xảy ra ngay cả khi tham số được khai báo là một mảng cố định:\n|code|\nChú ý: Để tránh nhầm lẫn về việc đang thao tác với mảng hay con trỏ, ưu tiên sử dụng cú pháp con trỏ (*) cho tham số hàm là mảng.\nTrên đây là bài viết của eLib.VN về Con trỏ và mảng trong C++. Việc sử dụng con trỏ để quản lý mảng một chiều thường được dùng khi viết các hàm thao tác với mảng. Chúc các bạn thuần thục và sử dụng dễ dàng hơn các thao tác liên quan đến mảng và con trỏ.\n              \n", "media": [], "code": [{"": "\n#include <iostream>\nusing namespace std;\n\nvoid printSize(int *array)\n{\n\t// tham số array là con trỏ int*\n\tcout << sizeof(array) << '\\n'; // kích thước con trỏ int*, không phải kích thước mảng\n}\n\nint main()\n{\n\tint array[] = { 5, 8, 2, 7 };\n\tcout << sizeof(array) << '\\n'; // kích thước mảng: sizeof(int) * array length\n\n\tprintSize(array); // đối số array được chuyển thành con trỏ int* tại đây\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n"}, {"": "\n14\n6\n\n"}, {"": "\nvoid printSize(int a[100]);\n\nvoid printSize(int a[]);\n"}], "table": []}{"ten_noi_dung": "Mảng 2 chiều trong C++", "ten_muc": "Mảng 2 chiều là gì?", "noi_dung": "Mảng 2 chiều trong C++ được biểu diễn dưới dạng hàng và cột, còn được gọi là ma trận. Nó còn được gọi là mảng các mảng hoặc danh sách các mảng.\nMảng 2 chiều, 3 chiều hoặc n chiều được gọi là mảng đa chiều trong C++.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Mảng 2 chiều trong C++", "ten_muc": "Khai báo mảng 2 chiều trong C++", "noi_dung": "|code|\nVí dụ:\n|code|\nỞ đây, 4 là số hàng và 3 là số cột.\n", "media": [], "code": [{"": "\ndata_type array_name[size1][size2];\n"}, {"": "\nint ma_tran [4][3];\n\n"}], "table": []}{"ten_noi_dung": "Mảng 2 chiều trong C++", "ten_muc": "Khởi tạo mảng 2 chiều trong C++", "noi_dung": " Khởi tạo mảng 2 chiều bằng mảng nặc danh.\n|code|\nKết quả:\n|code|\nKhởi tạo mảng 2 chiều bằng cách nhập data từ bàn phím.\n|code|\nKết quả:\n|code|\nTrên đây là bài viết của eLib.VN về mảng hai chiều trong C++. Mảng 2 chiều được sử dụng khá phổ biến trong lập trình, nó được ứng dụng vào các bài toán đồ thị, hoặc các trò chơi như game caro, cờ vua, …\n              \n", "media": [], "code": [{"": "\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int i = 0;\n    int j = 0;\n    // khai bao mang 2 chieu bang mang nac danh\n    int ma_tran[4][3] = {{ 1, 2, 3 }, {2, 3, 4}, {3, 4, 5}, {4, 5, 6}};\n    //duyet mang\n    for (i = 0; i < 4; i++) {\n     for (j = 0; j < 3; j++) {\n            cout << ma_tran[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n"}, {"": "\n1 2 3\n2 3 4\n3 4 5\n4 5 6\n"}, {"": "\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n int i, j;\n  \n    // khai bao mang 2 chieu bang mang nac danh\n    int ma_tran[4][3];\n     \n    //nhap mang\n    cout << \"Nhap mang: \\n\";\n    for (int i = 0; i < 4; i++) {\n     for (int j = 0; j < 3; j++) {\n      cout << \"Nhap a[\" << i << \"][\" << j << \"] = \";\n      cin >> ma_tran[i][j];\n        }\n        printf(\"\\n\");\n    }\n     \n    //duyet mang\n    cout << \"Ket qua: \\n\";\n    for (int i = 0; i < 4; i++) {\n     for (int j = 0; j < 3; j++) {\n            cout << ma_tran[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}\n"}, {"": "\nNhap mang:\nNhap a[0][0] = 1\nNhap a[0][1] = 2\nNhap a[0][2] = 3\n\nNhap a[1][0] = 4\nNhap a[1][1] = 5\nNhap a[1][2] = 6\n\nNhap a[2][0] = 7\nNhap a[2][1] = 8\nNhap a[2][2] = 9\n\nNhap a[3][0] = 10\nNhap a[3][1] = 11\nNhap a[3][2] = 12\n\nKet qua:\n1 2 3\n4 5 6\n7 8 9\n10 11 12\n\n"}], "table": []}{"ten_noi_dung": "Mảng (array) trong C++", "ten_muc": "Mảng (array) trong C++ là gì?", "noi_dung": "Mảng (array) trong C++ là một tập hoặc một nhóm các phần tử (dữ liệu) có kiểu dữ liệu đồng nhất(tương tự). Các phần tử của mảng được lưu trong các vùng nhớ liên tiếp.\nMảng trong C++ là rất hữu ích nếu bạn muốn lưu trữ các phần tử tương tự. Giả sử bạn phải lưu trữ thông tin của 50 sinh viên. Bạn có thể làm điều này bằng việc sử dụng 50 biến, nhưng với cách này bạn sẽ khó quản lý vì bạn không thể truy cập giá trị của các biến này với chỉ 1 hoặc 2 dòng code.\nMột cách khác để làm điều này là sử dụng mảng. Bằng cách sử dụng mảng, bạn có thể truy cập các phần tử một cách dễ dàng với chỉ vài dòng code.\n\n*Lưu ý:   Đối với mảng tĩnh,nếu khởi tạo thiếu cho các phần tử thì mặc định các phần tử đó được gán bằng 0.", "media": [], "code": [], "table": []}{"ten_noi_dung": "Mảng (array) trong C++", "ten_muc": "Lợi thế của mảng trong C++", "noi_dung": "Một số lợi thế của mảng:\n\tTối ưu hóa code.\n\tDễ dàng để duyệt các phần tử của mảng.\n\tDễ dàng sắp xếp dữ liệu.\n\tTruy cập ngẫu nhiên.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Mảng (array) trong C++", "ten_muc": "Bất lợi của mảng trong C++", "noi_dung": "Kích thước cố định: Kích thước của mảng trong C++ phải được định nghĩa tại thời điểm khai báo, chúng ta không thể lưu số phần tử vượt quá kích thước này vì chương trình có thể bị lỗi nếu một số dữ liệu quan trọng bị ghi đè.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Mảng (array) trong C++", "ten_muc": "Khai báo mảng (array) trong C++", "noi_dung": "Bạn có thể khai báo một mảng trong ngôn ngữ C++ theo cách sau.\n|code|\nVí dụ:\n|code|\nTrong đó, int là data_type, marks là array_name và 5 là array_size.\n", "media": [], "code": [{"": "\ndata_type array_name[array_size];\n"}, {"": "\nint marks[5];\n"}], "table": []}{"ten_noi_dung": "Mảng (array) trong C++", "ten_muc": "Khởi tạo mảng (array) trong C++", "noi_dung": "Chú ý rằng chỉ số mảng bắt đầu từ 0 và kết thúc bằng [SIZE-1].\n|code|\n|img|\nKhởi tạo mảng trong C++\n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201112/images/mang-array-trong-c-_1605173528.png", "Loai": "img"}], "code": [{"": "\nmarks[0] = 80; // khoi tao mang\nmarks[1] = 60; \nmarks[2] = 70; \nmarks[3] = 85; \nmarks[4] = 75; \n"}], "table": []}{"ten_noi_dung": "Mảng (array) trong C++", "ten_muc": "Ví dụ mảng trong C++", "noi_dung": "|code|\nKết quả:\n|code|\n", "media": [], "code": [{"": "\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int i = 0;\n    int marks[5];  // khai bao mang\n    marks[0] = 80; // khoi tao mang\n    marks[1] = 60;\n    marks[2] = 70;\n    marks[3] = 85;\n    marks[4] = 75;\n    //duyet mang\n    for (i = 0; i < 5; i++) {\n        cout << marks[i] << endl;\n    }\n    return 0;\n}\n\n"}, {"": "\n80\n60\n70\n85\n75\n"}], "table": []}{"ten_noi_dung": "Mảng (array) trong C++", "ten_muc": "Khai báo với khởi tạo mảng nặc danh trong C++", "noi_dung": "Trong lập trình C++, chúng ta có thể khởi tạo mảng nặc danh khi khai báo mảng. Ví dụ:\n|code|\nTrong trường hợp này, mảng marks có kích thước bằng kích thước của mảng nặc danh.\nVí dụ về mảng nặc danh số nguyên:\n|code|\nKết quả:\n|code|\nVí dụ về mảng nặc danh có kiểu dữ liệu là char:\n|code|\nKết quả:\n|code|\n\n*Lưu ý: Mảng static được tự động khởi tạo với giá trị 0\n\n              \n", "media": [], "code": [{"": "\nint marks[5] = {20, 30, 40, 50, 60};\n"}, {"": "\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int i = 0;\n    // khai bao mang nac danh\n    int marks[5]={20, 30, 40, 50, 60};\n    //duyet mang\n    for (i = 0; i < 5; i++) {\n        cout << marks[i] << endl;\n    }\n    return 0;\n}\n"}, {"": "\n20\n30\n40\n50\n60\n"}, {"": "\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int i = 0;\n    // khai bao mang nac danh\n    char c[7]={'h', 'o', 'c', ' ', 'C', '+', '+'};\n    //duyet mang\n    for (i = 0; i < 7; i++) {\n        cout << c[i] << \" \";\n    }\n    return 0;\n}\n"}, {"": "\nhoc C + + \n"}], "table": []}{"ten_noi_dung": "Truyền mảng vào hàm trong C++", "ten_muc": "Truyền mảng tới hàm trong C++", "noi_dung": "Để truyền dữ liệu của mảng vào hàm, chúng ta có thể tạo các hàm nhận mảng làm đối số. Để truyền mảng trong hàm, chúng ta chỉ cần viết tên mảng trong lệnh gọi hàm.\n|code|\nCó 3 cách để khai báo hàm nhận mảng làm đối số:\nCách thứ nhất:\n|code|\nKhai báo ký hiệu chỉ số trống [] là kỹ thuật được sử dụng rộng rãi.\nCách thứ hai:\n|code|\nTheo tùy chọn, chúng ta có thể xác định kích thước của mảng trong ký hiệu chỉ số [].\nCách thứ ba:\n|code|\nBạn cũng có thể sử dụng khái niệm con trỏ.\n", "media": [], "code": [{"": "\nfunction_name(array_name); // truyền mảng\n"}, {"": "\nreturn_type function(type array_name[])\n\n"}, {"": "\nreturn_type function(type array_name[SIZE])\n\n"}, {"": "\nreturn_type function(type *array_name)\n\n"}], "table": []}{"ten_noi_dung": "Truyền mảng vào hàm trong C++", "ten_muc": "Truyền một phần tử của mảng một chiều vào hàm trong C++", "noi_dung": "Một phần tử của một mảng có thể được truyền theo cách tương tự như truyền biến cho một hàm. Ví du:\n|code|\nKết quả:\n|code|\n", "media": [], "code": [{"": "\n#include <iostream>\n\nusing namespace std;\n\nvoid display(int age) {\n    cout << age;\n}\n\nint main() {\n    int ageArray[] = { 2, 3, 4 };\n    display(ageArray[2]); //chi truyen phan tu ageArray[2].\n    return 0;\n}\n"}, {"": "\n4\n"}], "table": []}{"ten_noi_dung": "Truyền mảng vào hàm trong C++", "ten_muc": "Truyền toàn bộ mảng một chiều vào hàm", "noi_dung": "Trong khi truyền các mảng làm đối số cho hàm, chỉ có tên của mảng được truyền (tức là địa chỉ bắt đầu của vùng nhớ được chuyển làm đối số).\nChương trình C++ truyền một mảng chứa tuổi của người vào một hàm. Hàm này tìm độ tuổi trung bình và hiển thị độ tuổi trung bình trong hàm main().\n|code|\nKết quả:\n|code|\n", "media": [], "code": [{"": "\n#include <iostream>\n\nusing namespace std;\n\n// dinh nghia prototype\nfloat average(float age[]);\n\nint main() {\n float avg, age[] = { 23.4, 20, 22.6, 3, 40.5, 18};\n avg = average(age); // chi ten cua mang duoc truyen nhu mot doi so\n cout << \"Tuoi trung binh la: \" << avg;\n return 0;\n}\n\nfloat average(float age[]) {\n int i;\n float avg, sum = 0.0;\n for (i = 0; i < 6; ++i) {\n  sum += age[i];\n }\n avg = (sum / 6);\n return avg;\n}\n"}, {"": "\nTuoi trung binh la: = 21.25\n"}], "table": []}{"ten_noi_dung": "Truyền mảng vào hàm trong C++", "ten_muc": "Truyền mảng đa chiều vào hàm", "noi_dung": "Để truyền mảng hai chiều tới một hàm làm đối số, địa chỉ bắt đầu của vùng bộ nhớ được đặt trước được truyền như trong mảng một chiều.\nVí dụ: Truyền các mảng hai chiều đến một hàm.\n|code|\nKết quả:\n|code|\nTrên đây là bài viết của eLib.VN về Truyền mảng vào hàm trong C++. Việc sử dụng mảng như là tham số của hàm thì cũng không khác gì với việc sử dụng các biến. Bạn đọc có thể nghiên cứu và tham khảo thêm. Chúc các bạn thành công!\nNhư vậy là chúng ta đã hoàn thành nội dung \"C++ Array\". Để củng cố và nắm vững nội dung đã học, mời bạn cùng thử sức với \"Bộ Câu hỏi\nTrắc Nghiệm\n              \n", "media": [], "code": [{"": "\n#include <iostream>\n\nusing namespace std;\n\nconst int ARR_X = 3;\nconst int ARR_Y = 4;\n\n// dinh nghia prototype\nvoid displayNumbers(int num[ARR_X][ARR_Y]);\n\nint main() {\n    int num[ARR_X][ARR_Y], i, j;\n    printf(\"Nhap mang num :\\n\");\n    for (i = 0; i < ARR_X; i++) {\n        for (j = 0; j < ARR_Y; j++) {\n            printf(\"num[%d][%d]=\", i, j);\n            cin >> num[i][j];\n        }\n    }\n    // truyen mang da chieu vao ham displayNumbers\n    displayNumbers(num);\n    return 0;\n}\n\n/*\n * hien thi mang 2 chieu\n*/\nvoid displayNumbers(int num[ARR_X][ARR_Y]) {\n    int i, j;\n    printf(\"Mang 2 chieu:\\n\");\n    for (i = 0; i < ARR_X; i++) {\n        for (j = 0; j < ARR_Y; j++) {\n            printf(\"%d \", num[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n"}, {"": "\nNhap mang num :\nnum[0][0]=1\nnum[0][1]=2\nnum[0][2]=3\nnum[0][3]=4\nnum[1][0]=5\nnum[1][1]=6\nnum[1][2]=7\nnum[1][3]=8\nnum[2][0]=9\nnum[2][1]=10\nnum[2][2]=11\nnum[2][3]=12\nMang 2 chieu:\n1 2 3 4\n5 6 7 8\n9 10 11 12\n"}], "table": []}{"ten_noi_dung": "Cấp phát động trong C++", "ten_muc": "Mảng động", "noi_dung": "Mảng động là một topic quan trọng trong C++, việc sử dụng mảng thông thường, bạn sẽ không thể thay đổi kích thước của mảng (thêm khi cần và xóa khi không cần), mảng động sẽ giải quyết việc này. Để cấp phát một mảng động, ta sử dụng toán tử new và sau kiểu dữ liệu phải cung cấp số lượng phần tử [size]: \n|code| \nHệ điều hành sẽ cấp phát cho biến động một dãy các vùng nhớ liền kề nhau, mỗi vùng nhớ có kích thước bằng với kích thước của phần tử của mảng đó. Tương tự với mảng thông thường bạn vẫn phải cung cấp kích thước mảng và kích thước đó phải là hằng. Và cũng tương tự như biến động thông thường, bạn vẫn quản lý thông qua con trỏ như sau: \n|code| \nĐối với mảng động, toán tử new sẽ trả về con trỏ trỏ vào ô nhớ đầu tiên của vùng nhớ được cấp phát cho mảng đó. Việc thao tác với mảng động thực hiện qua con trỏ cũng tương tự như đối với mảng thông thường như sau: \n|code| \nHoặc thao tác theo cách “con trỏ style” như sau: \n|code| \nViệc thực hiện myArr + i tức là lấy địa chỉ của con trỏ myArr (tức địa chỉ phần tử đầu tiên) rồi cộng thêm i lần kích thước của mỗi vùng nhớ. Ví dụ như kiểu byte có kích thước là 4 byte, myArr đang trỏ vào phần tử đầu tiên giả sử địa chỉ 0x50, khi gọi đến myArr là phần tử đầu tiên nghĩa là không cộng thêm gì hết là chính nó do con trỏ trỏ vào phần tử đầu tiên của mảng tức là 0x50. Gọi myArr + 1 tức là địa chỉ của phần tử đầu tiên cộng với 1 lần kích thước của kiểu int là 4 byte, tức là phần tử 0x54, sau đó dùng toán tử * để lấy giá trị như ví dụ bên trên. \n \nVà cũng để tránh rò rỉ bộ nhớ, không dùng đến nữa thì ta cũng phải xóa mảng động đi. Để xóa mảng động đi nó có hơi khác một chút là có dấu [] sau toán tử delete. \n|code| \nVậy thì việc thay đổi kích thước mảng thực hiện ra làm sao? Bạn sẽ không có phương thức hỗ trợ nào mà phải làm thủ công. Tức là bạn sẽ phải tạo một mảng mới với kích thước phần tử mới, sau đó copy phần tử sang mảng mới và xóa mảng cũ đi như sau: \n|code| \nVề bản chất, mảng thông thường thật ra chính là một mảng động được một hằng con trỏ trỏ tới: \n|code|\n", "media": [], "code": [{"": "\nnew <kiểu_dữ_liệu_của_mỗi_phần_tử>[size]; \n// ví dụ \nnew int[100];\n"}, {"": "\nint *myArr = new int[100];\n"}, {"": "\nmyArr[0] = 1;\nmyArr[1] = 2;\n"}, {"": "\n*(myArr + 0) = 1;\n*(myArr + 1) = 2;\n"}, {"": "\ndelete[] ptr;\n"}, {"": "\n// Tạo mảng mới \nint newSize = 5; \nint* newArr = new int[newSize]; \n \n// Copy phần tử từ mảng cũ sang mảng mới \nfor (auto i = 0; i < size; i++)\n\tnewArr[i] = arr[i]; \n \n// Xóa mảng cũ đi \ndelete[] arr; \narr = nullptr;\n"}, {"": "\nint *const arr = new int[10];\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử gán trong C++", "ten_muc": "Nạp chồng toán tử gán trong C++", "noi_dung": "Bạn có thể nạp chồng toán tử gán (=) như khi bạn có thể với các toán tử khác trong C++ và nó có thể được sử dụng để tạo một đối tượng giống như copy constructor.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử gán trong C++", "ten_muc": "Ví dụ Nạp chồng toán tử gán trong C++", "noi_dung": "Ví dụ sau minh họa cách nạp chồng toán tử gán trong C++:\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử gán trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu-gan-trong-c-_1603944006.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\nusing namespace std;\n\nclass KhoangCach\n{\nprivate:\n    int met;\n    int centimet;\npublic:\n    // phan khai bao cac constructor can thiet\n    KhoangCach() {\n        met = 0;\n        centimet = 0;\n    }\n    KhoangCach(int m, int c) {\n        met = m;\n        centimet = c;\n    }\n    void operator=(const KhoangCach& K)\n    {\n        met = K.met;\n        centimet = K.centimet;\n    }\n    // phuong thuc de hien thi khoang cach\n    void hienthiKC()\n    {\n        cout << \"\\nDo dai bang m la: \" << met <<\n            \"\\nVa do dai bang cm la: \" << centimet << endl;\n    }\n\n};\nint main()\n{\n    KhoangCach K1(10, 16), K2(15, 50);\n    cout << \"Khoang cach dau tien: \";\n    K1.hienthiKC();\n    cout << \"\\n-------------------\\n\";\n    cout << \"Khoang cach thu hai:\";\n    K2.hienthiKC();\n    // su dung toan tu gan\n    K1 = K2;\n    cout << \"\\n-------------------\\n\";\n    cout << \"Khoang cach dau tien: \";\n    K1.hienthiKC();   return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử gọi hàm () trong C++", "ten_muc": "Nạp chồng toán tử gọi hàm () trong C++", "noi_dung": "Toán tử gọi hàm () trong C++ có thể được nạp chồng cho các đối tượng của kiểu lớp. Khi bạn nạp chồng (), bạn đang không tạo một cách mới để gọi một hàm. Đúng hơn là, bạn đang tạo một hàm toán tử mà có thể được truyền số tham số tùy ý.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử gọi hàm () trong C++", "ten_muc": "Ví dụ Nạp chồng toán tử gọi hàm () trong C++", "noi_dung": "Ví dụ sau minh họa cách nạp chồng toán tử gọi hàm () trong C++:\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử gọi hàm () trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu-goi-ham-trong-c-_1603945171.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\nusing namespace std;\n\nclass KhoangCach\n{\nprivate:\n    int met;\n    int centimet;\npublic:\n    // phan khai bao cac constructor can thiet\n    KhoangCach() {\n        met = 0;\n        centimet = 0;\n    }\n    KhoangCach(int m, int c) {\n        met = m;\n        centimet = c;\n    }\n    // nap chong toan tu goi ham ()\n    KhoangCach operator()(int x, int y, int z)\n    {\n        KhoangCach K;\n        // bay gio, dat phep tinh bat ky\n        K.met = x + y + 5;\n        K.centimet = y - z + 20;\n        return K;\n    }\n    // Phuong thuc de hien thi khoang cach\n    void hienthiKC()\n    {\n        cout << \"\\nDo dai bang m la: \" << met <<\n            \"\\nVa do dai bang cm la: \" << centimet << endl;\n    }\n\n};\n\nint main()\n{\n    KhoangCach K1(25, 40), K2;\n    cout << \"Khoang cach dau tien la: \";\n    K1.hienthiKC();   K2 = K1(15, 15, 15);\n    // trieu hoi toan tu ()\n    cout << \"\\n--------------------------\\n\";\n    cout << \"Khoang cach thu hai la: \";\n    K2.hienthiKC();   return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử Input/Output trong C++", "ten_muc": "Nạp chồng toán tử Input/Output trong C++", "noi_dung": "C++ là có thể input và output các kiểu dữ liệu có sẵn bởi sử dụng toán tử trích luồng >> và toán tử chèn luồng <<. Các toán tử trích luồng và chèn luồng cũng có thể được nạp chồng để thực hiện input và output cho các kiểu tự định nghĩa (user-defined).\nỞ đây, nó là quan trọng để tạo một hàm nạp chồng toán tử một friend của lớp, bởi vì nó sẽ được gọi mà không tạo một đối tượng.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử Input/Output trong C++", "ten_muc": "Ví dụ Nạp chồng toán tử Input/Output trong C++", "noi_dung": "Ví dụ sau giải thích cách nạp chồng toán tử trích luồng >> và toán tử chèn luồng << trong C++:.\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử Input/Output trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu-input-output-trong-c-_1603941994.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\nusing namespace std;\n\nclass KhoangCach\n{\nprivate:\n    int met;\n    int centimet;\npublic:\n    // phan khai bao cac constructor can thiet\n    KhoangCach() {\n        met = 0;\n        centimet = 0;\n    }\n    KhoangCach(int m, int c) {\n        met = m;\n        centimet = c;\n    }\n    friend ostream& operator<<(ostream& output,\n        const KhoangCach& K)\n    {\n        output << \"\\nDo dai bang m la: \" <<\n            K.met << \"\\nVa do dai bang cm la: \" << K.centimet;\n        return output;\n    }      friend istream& operator>>(istream& input, KhoangCach& K)\n    {\n        input >> K.met >> K.centimet;\n        return input;\n    }\n};\n\nint main()\n{\n    KhoangCach K1(20, 15), K2(15, 50), K3;\n    cout << \"Nhap gia tri cua doi tuong K3: \" << endl;\n    cin >> K3;\n    cout << \"Khoang cach dau tien: \" << K1 << endl;\n    cout << \"\\n==========================\\n\" << endl;\n    cout << \"Khoang cach thu hai: \" << K2 << endl;\n    cout << \"\\n==========================\\n\" << endl;\n    cout << \"Khoang cach thu ba: \" << K3 << endl;\n    return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử một ngôi trong C++", "ten_muc": "Nạp chồng toán tử một ngôi trong C++", "noi_dung": "Toán tử một ngôi (unary) trong C++ hoạt động trên một toán hạng đơn và dưới đây là một số ví dụ về toán tử một ngôi:\n\t\n\tNạp chồng toán tử tăng (++) và toán tử giảm (--) trong C++.\n\t\n\t\n\tToán tử một ngôi (-) trong C++\n\t\n\t\n\tToán tử logic phủ định (!) trong C++\n\t\nToán tử một ngôi hoạt động trên đối tượng mà chúng được gọi, và thường thì toán tử này xuất hiện bên trái đối tượng, dạng như: !obj, -obj, và ++obj, nhưng đôi khi chúng có thể sử dụng như là hậu tố giống như obj++ hoặc obj--.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử một ngôi trong C++", "ten_muc": "Ví dụ nạp chồng toán tử một ngôi trong C++", "noi_dung": "Ví dụ sau giải thích cách toán tử (-) có thể được nạp chồng với sự sử dụng tiền tố cũng như hậu tố.\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử một ngôi trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu-mot-ngoi-trong-c-_1603939218.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\nusing namespace std;\n\nclass KhoangCach\n{\nprivate:\n    int met;\n    int centimet;\npublic:\n    // khai bao cac constructor\n    KhoangCach() {\n        met = 0;\n        centimet = 0;\n    }\n    KhoangCach(int m, int c) {\n        met = m;\n        centimet = c;\n    }\n    // phuong thuc de hien thi khoang cach\n    void hienthiKC()\n    {\n        cout << \"Khoang cach bang m la: \" << met << endl;\n        cout << \"Khoang cach bang cm la: \" << centimet << endl;\n        cout << \"\\n\\n================================\\n\\n\" << endl;\n    }\n    // nap chong toan tu (-)\n    KhoangCach operator- ()\n    {\n        met = -met;\n        centimet = -centimet;\n        return KhoangCach(met, centimet);\n    }\n};\n\nint main()\n{\n    KhoangCach K1(10, 50), K2(-12, 15);\n    -K1;               // ap dung su phu dinh\n    K1.hienthiKC();    // hien thi K1\n    -K2;               // ap dung su phu dinh\n    K2.hienthiKC();    // hien thi K2\n    return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử nhị phân trong C++", "ten_muc": "Nạp chồng toán tử nhị phân trong C++", "noi_dung": "Các toán tử nhị phân trong C++ nhận hai tham số. Bạn sử dụng toán tử nhị phân khá thường xuyên, ví dụ như toán tử cộng (+), toán tử trừ (-) và toán tử chia (/).\nToán tử nhị phân (Binary Operator) sẽ hoạt động với 2 toán hạng. Một số ví dụ về toán tử nhị phân bao gồm toán tử số học (+, -, *, /, %), toán tử gán số học (+=, -+, *=, /+, %=) và toán tử quan hệ, ... . Nạp chồng toán tử nhị phân tương tự nạp chồng toán tử một ngôi, ngoại trừ toán tử nhị phân yêu cầu thêm tham số bổ sung.\nCú pháp nạp chồng toán tử nhị phân:\n|code|\nTrong đó toán tử là biểu tượng, biểu thị cho toán tử nhị phân.\n|code|\n", "media": [], "code": [{"": "\nToán tử toán tử (đối tượng 1, đối tượng 2);\n"}, {"": "\ntoán tử + (a, b);\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử nhị phân trong C++", "ten_muc": "Ví dụ nạp chồng toán tử nhị phân trong C++", "noi_dung": "Ví dụ sau giải thích cách toán tử cộng (+) có thể được nạp chồng trong C++. Tương tự, bạn có thể nạp chồng toán tử trừ (-) và toán tử chia (/).\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử nhị phân trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu-nhi-phan-trong-c-_1603940379.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\nusing namespace std;\n  \nclass Box\n{\npublic:\n    double tinhTheTich(void)\n    {\n        return chieudai * chieurong * chieucao;\n    }\n    void setChieuDai(double dai)\n    {\n        chieudai = dai;\n    }     \n    void setChieuRong(double rong)\n    {\n        chieurong = rong;\n    }\n    void setChieuCao(double cao)\n    {\n        chieucao = cao;\n    }\n  \n    // Nap chong toa tu + de cong hai doi tuong Box.\n    Box operator+(const Box& b)\n    {\n        Box box;\n        box.chieudai = this->chieudai + b.chieudai;\n        box.chieurong = this->chieurong + b.chieurong;\n        box.chieucao = this->chieucao + b.chieucao;\n        return box;\n    }\nprivate:\n    double chieudai;      // chieu dai cua mot box\n    double chieurong;     // Chieu rong cua mot box\n    double chieucao;      // Chieu cao cua mot box\n};\n// ham main cua chuong trinh\nint main()\n{\n    Box Box1;                // Khai bao Box1 la cua kieu Box\n    Box Box2;                // Khai bao Box2 la cua kieu Box\n    Box Box3;                // Khai bao Box3 la cua kieu Box\n    double thetich = 0.0;    // Luu giu the tich cua mot box tai day\n  \n    // thong tin chi tiet cua box 1\n    Box1.setChieuDai(3.0);\n    Box1.setChieuRong(4.0);\n    Box1.setChieuCao(5.0);\n  \n    // thong tin chi tiet cua box 2\n    Box2.setChieuDai(6.0);\n    Box2.setChieuRong(7.0);\n    Box2.setChieuCao(8.0);\n  \n    // the tich cua box 1\n    thetich = Box1.tinhTheTich();\n    cout << \"The tich cua Box1 la: \" << thetich << endl;\n  \n    // the tich cua box 2\n    thetich = Box2.tinhTheTich();\n    cout << \"The tich cua Box2 la: \" << thetich << endl;\n    // cong hai doi tuong nhu sau:\n    Box3 = Box1 + Box2;\n    // the tich cua box 3\n    thetich = Box3.tinhTheTich();\n    cout << \"The tich cua Box3 la: \" << thetich << endl;\n    return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử quan hệ trong C++", "ten_muc": "Nạp chồng toán tử quan hệ trong C++", "noi_dung": "Có nhiều toán tử quan hệ đa dạng được hỗ trợ bởi C++, ví dụ như: (<, >, <=, >=, ==, ...) mà có thể được sử dụng để so sánh các kiểu dữ liệu có sẵn trong C++.\nBạn có thể nạp chồng bất kỳ toán tử quan hệ nào, mà có thể được sử dụng để so sánh các đối tượng của một lớp.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử quan hệ trong C++", "ten_muc": "Ví dụ Nạp chồng toán tử quan hệ trong C++", "noi_dung": "Ví dụ sau giải thích cách toán tử < trong C++ có thể được nạp chồng và theo cách tương tự, bạn có thể nạp chồng các toán tử quan hệ khác trong C++:\n|code|\n              \n", "media": [], "code": [{"": "\n#include <iostream>\nusing namespace std;\n\nclass KhoangCach\n{\nprivate:\n    int met;\n    int centimet;\npublic:\n    // phan khai bao cac constructor can thiet\n    KhoangCach() {\n        met = 0;\n        centimet = 0;\n    }\n    KhoangCach(int m, int c) {\n        met = m;\n        centimet = c;\n    }      // nap chong toan tu <\n    bool operator <(const KhoangCach& k)\n    {\n        if (met < k.met)\n        {\n            return true;\n        }\n        if (met == k.met && centimet < k.centimet)\n        {\n            return true;\n        }\n        return false;\n    }\n};\n\nint main()\n{\n    KhoangCach K1(10, 15), K2(5, 20);\n\n    if (K1 < K2)\n    {\n        cout << \"K1 la ngan hon K2 \" << endl;\n    }\n    else\n    {\n        cout << \"K2 la ngan hon K1 \" << endl;\n    }\n    return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử subscript [] trong C++", "ten_muc": "Nạp chồng toán tử subscript [] trong C++", "noi_dung": "Toán tử subscript [] trong C++ thường được sử dụng để truy cập các phần tử mảng. Toán tử này có thể được nạp chồng để nâng cao tính năng đang tồn tại về mảng trong C++ (do vậy, có thể gọi là toán tử chỉ số mảng).\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử subscript [] trong C++", "ten_muc": "Ví dụ Nạp chồng toán tử subscript [] trong C++", "noi_dung": "Ví dụ sau minh họa cách nạp chồng toán tử subscript [] trong C++:\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nNạp chồng toán tử subscript [] trong C++\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử subscript [] trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu-subscript-trong-c-_1603946079.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\nusing namespace std;\nconst int SIZE = 15;\nclass ViDuMang\n{\nprivate:\n    int mang[SIZE];\npublic:\n    ViDuMang()\n    {\n        register int i;\n        for (i = 0; i < SIZE; i++)\n        {\n            mang[i] = i;\n        }\n    }\n    int& operator[](int i)\n    {\n        if (i > SIZE)\n        {\n            cout << \"\\n======================\\n\" << endl;\n            cout << \"Chi muc vuot gioi han!\" << endl;\n            // Tra ve phan tu dau tien.\n            return mang[0];\n        }\n        return mang[i];\n    }\n};\nint main()\n{\n    ViDuMang V;   cout << \"Gia tri cua V[3] la: \" << V[3] << endl;\n    cout << \"Gia tri cua V[6] la: \" << V[6] << endl;\n    cout << \"Gia tri cua V[16] la: \" << V[16] << endl;   return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử truy cập thành viên lớp (->) trong C++", "ten_muc": "Nạp chồng toán tử truy cập thành viên lớp (->) trong C++", "noi_dung": "Toán tử truy cập thành viên lớp (->) có thể được nạp chồng, nhưng nó khá là phức tạp. Nó được định nghĩa để cung cấp một kiểu lớp một hành vi \"pointer-like\". Toán tử -> phải là một hàm thành viên. Nếu được sử dụng, kiểu trả về của nó phải là một con trỏ hoặc một đối tượng của một lớp để bạn có thể áp dụng.\nToán tử -> thường được sử dụng kết hợp với toán tử * để triển khai \"smart pointer\". Những con trỏ này là các đối tượng mà vận hành như các con trỏ thông thường, ngoại trừ việc chúng thực hiện các tác vụ khi bạn truy cập một đối tượng thông qua chúng, ví dụ: xóa đối tượng tự động hoặc khi con trỏ bị hủy hoặc khi con trỏ được sử dụng để trỏ tới đối tượng khác.\nToán tử -> có thể được định nghĩa như là một toán tử hậu tố một ngôi.\n|code|\nCác đối tượng của lớp Ptr có thể được sử dụng để truy cập các thành viên của lớp X ở trên theo phương thức giống như cách các con trỏ được sử dụng. Ví dụ:\n|code|\nLệnh p->m được thông dịch thành (p.operator->())->m.\n", "media": [], "code": [{"": "\nclass Ptr{\n   //...\n   X * operator->();\n};\n"}, {"": "\nvoid f(Ptr p )\n{\n   p->m = 10 ; // la tuong tu (p.operator->())->m = 10\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử truy cập thành viên lớp (->) trong C++", "ten_muc": "Ví dụ Nạp chồng toán tử truy cập thành viên lớp (->) trong C++", "noi_dung": "Sử dụng cùng khái niệm trên, ví dụ sau sẽ giải thích cách một toán tử truy cập lớp -> trong C++ có thể được nạp chồng.\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nNạp chồng toán tử truy cập thành viên lớp (->) trong C++\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử truy cập thành viên lớp (->) trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\nCNhư vậy là chúng ta đã hoàn thành nội dung \"Nạp chồng toán tử trong C++ \". Để củng cố và nắm vững nội dung đã học, mời bạn cùng thử sức với \"Bộ Câu hỏi\nTrắc Nghiệm\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201112/images/nap-chong-toan-tu_1605173567.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// gia su co mot lop eLib sau.\nclass eLib {\n    static int i, j;\npublic:\n    // cac smart pointer de hien thi\n    void f() const { cout << i++ << endl; }\n    void g() const { cout << j++ << endl; }\n    void h() const { cout << \"--------\" << endl; }\n};// phan dinh nghia cac thanh vien Static:\n\nint eLib::i = 5;\nint eLib::j = 20;\n\n// Trien khai mot container cho lop tren\nclass VTContainer {\n    vector<eLib*> a;\npublic:\n    void add(eLib* vj)\n    {\n        a.push_back(vj);  // goi phuong thuc chuan cua vector.\n    }\n    friend class SmartPointer;\n};\n\n// trien khai smart pointer de truy cap thanh vien cua lop eLib.\nclass SmartPointer {\n    VTContainer vc;\n    int index;\npublic:\n    SmartPointer(VTContainer& vjc)\n    {\n        vc = vjc;\n        index = 0;\n    }\n    // tra ve gia tri de chi phan cuoi cua danh sach:\n    bool operator++() // phien ban toan tu ++ (tien to)\n    {\n        if (index >= vc.a.size()) return false;\n        if (vc.a[++index] == 0) return false;\n        return true;\n    }\n    bool operator++(int) // phien ban toan tu ++ (hau to)\n    {\n        return operator++();\n    }\n    // nap chong operator->\n    eLib* operator->() const\n    {\n        if (!vc.a[index])\n        {\n            cout << \"Gia tri 0!!\";\n            return (eLib*)0;\n        }\n        return vc.a[index];\n    }\n};int main() {\n    // so vong lap la 5 (ban thiet lap gia tri khac de xem ket qua)\n    const int sz = 5;\n    eLib o[sz];\n    VTContainer vc;\n    for (int i = 0; i < sz; i++)\n    {\n        vc.add(&o[i]);\n    }\n    SmartPointer sp(vc); // tao mot iterator\n    do {\n        sp->f(); // goi smart pointer\n        sp->g();\n        sp->h();\n    } while (sp++);\n    return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử và Nạp chồng hàm trong C++", "ten_muc": "Nạp chồng toán tử và Nạp chồng hàm trong C++", "noi_dung": "Nạp chồng hàm (function overloading) và Nạp chồng toán tử (operator overloading) trong C++ cho phép bạn xác định nhiều hơn một định nghĩa cho một tên hàm hoặc một toán tử trong cùng phạm vi (scope), được gọi tương ứng.\nMột khai báo nạp chồng là một khai báo mà đã được khai báo với cùng tên như một khai báo được khai báo trước đó trong cùng phạm vi, ngoại trừ rằng: cả hai khai báo có các tham số khác nhau và định nghĩa khác nhau.\nKhi bạn gọi một hàm nạp chồng hoặc một toán tử nạp chồng, thì compiler quyết định định nghĩa thích hợp nhất để sử dụng bằng việc so sánh các kiểu tham số bạn đã sử dụng để gọi hàm hoặc toán tử với các kiểu tham số đã được xác định trong các định nghĩa. Tiến trình lựa chọn hàm nạp chồng hoặc toán tử nạp chồng thích hợp nhất này được gọi là overload resolution - phân giải nạp chồng.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử và Nạp chồng hàm trong C++", "ten_muc": "Nạp chồng toán tử trong C++", "noi_dung": "Bạn có thể định nghĩa lại hoặc nạp chồng hầu hết các toán tử có sẵn trong C++. Vì thế, một lập trình viên có thể sử dụng các toán tử với kiểu tự định nghĩa (user-defined).\nNạp chồng toán tử trong C++ là các hàm với tên đặc biệt: Tên hàm là từ khóa operator theo sau là ký hiệu của toán tử đang được định nghĩa. Giống như bất kỳ hàm khác, một toán tử nạp chồng có một kiểu trả về và một danh sách tham số.\n|code|\nKhai báo toán tử + để cộng hai đối tượng Box và trả về đối tượng Box cuối cùng. Hầu hết toán tử nạp chồng có thể được định nghĩa dưới dạng: các hàm không có thành viên (non-member) hoặc các hàm thành viên lớp. Trong trường hợp trên, chúng ta định nghĩa hàm ở dạng non-member của một lớp, thì sau đó chúng ta phải truyền hai tham số cho mỗi toán hạng, như sau:\n|code|\nVí dụ sau minh họa khái niệm nạp chồng toán tử bởi sử dụng một hàm thành viên. Ở đây, một đối tượng được truyền như là một tham số mà các thuộc tính của nó sẽ được truy cập bởi sử dụng đối tượng này, đối tượng mà sẽ gọi toán tử này có thể được truy cập bởi sử dụng toán tử this, như sau:\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu2_1603936394.png", "Loai": "img"}], "code": [{"": "\nBox operator+(const Box&);\n"}, {"": "\nBox operator+(const Box&, const Box&);\n"}, {"": "\n#include <iostream>\nusing namespace std;\n\nclass Box\n{\npublic:\n    double tinhTheTich(void)\n    {\n        return chieudai * chieurong * chieucao;\n    }\n    void setChieuDai(double dai)\n    {\n        chieudai = dai;\n    }     \n    void setChieuRong(double rong)\n    {\n        chieurong = rong;\n    }\n    void setChieuCao(double cao)\n    {\n        chieucao = cao;\n    }\n\n    // Nap chong toa tu + de cong hai doi tuong Box.\n    Box operator+(const Box& b)\n    {\n        Box box;\n        box.chieudai = this->chieudai + b.chieudai;\n        box.chieurong = this->chieurong + b.chieurong;\n        box.chieucao = this->chieucao + b.chieucao;\n        return box;\n    }\nprivate:\n    double chieudai;      // chieu dai cua mot box\n    double chieurong;     // Chieu rong cua mot box\n    double chieucao;      // Chieu cao cua mot box\n};\n// ham main cua chuong trinh\nint main()\n{\n    Box Box1;                // Khai bao Box1 la cua kieu Box\n    Box Box2;                // Khai bao Box2 la cua kieu Box\n    Box Box3;                // Khai bao Box3 la cua kieu Box\n    double thetich = 0.0;    // Luu giu the tich cua mot box tai day\n\n    // thong tin chi tiet cua box 1\n    Box1.setChieuDai(3.0);\n    Box1.setChieuRong(4.0);\n    Box1.setChieuCao(5.0);\n\n    // thong tin chi tiet cua box 2\n    Box2.setChieuDai(6.0);\n    Box2.setChieuRong(7.0);\n    Box2.setChieuCao(8.0);\n\n    // the tich cua box 1\n    thetich = Box1.tinhTheTich();\n    cout << \"The tich cua Box1 la: \" << thetich << endl;\n\n    // the tich cua box 2\n    thetich = Box2.tinhTheTich();\n    cout << \"The tich cua Box2 la: \" << thetich << endl;\n    // cong hai doi tuong nhu sau:\n    Box3 = Box1 + Box2;\n    // the tich cua box 3\n    thetich = Box3.tinhTheTich();\n    cout << \"The tich cua Box3 la: \" << thetich << endl;\n    return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử và Nạp chồng hàm trong C++", "ten_muc": "Toán tử có thể nạp chồng và không thể nạp chồng trong C++", "noi_dung": "Bảng dưới liệt kê danh sách các toán tử có thể được nạp chồng trong C++:\n|table|\nCòn đây là danh sách các toán tử không thể được nạp chồng trong C++:\n|table|\n", "media": [], "code": [], "table": [{"": {"0": ["+", "&", "<", "<<", "+=", "|=", "->"], "1": ["-", "|", ">", ">>", "-=", "*=", "->*"], "2": ["*", "~", "<=", "==", "/=", "<<=", "new"], "3": ["/", "!", ">=", "!=", "%=", ">>=", "new []"], "4": ["%", ",", "++", "&&", "^=", "[]", "delete"], "5": ["^", "=", "--", "||", "&=", "()", "delete []"]}}, {"": {"0": ["::"], "1": [".*"], "2": ["."], "3": ["?:"]}}]}{"ten_noi_dung": "Nạp chồng toán tử và Nạp chồng hàm trong C++", "ten_muc": "Ví dụ về Nạp chồng toán tử trong C++", "noi_dung": "Dưới đây là các ví dụ đa dạng minh họa Nạp chồng toán tử trong C++, từ đó giúp bạn hiểu sâu hơn về khái niệm này. Bạn click vào link để thấy ví dụ:\n|table|\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử và Nạp chồng hàm trong C++. Nạp chồng (overloading) toán tử thường được người lập trình sử dụng rất nhiều trong lập trình hướng đối tượng. Vì vậy bạn đọc cần lưu ý. \n              \n", "media": [], "code": [], "table": [{"": {"STT": ["1", "2", "3", "4", "5", "6", "7", "8", "9"], "Toán tử và Ví dụ": ["\n\t\t\tNạp chồng toán tử một ngôi (unary) trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử nhị phân trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử quan hệ trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử Input/Output trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử ++ và -- trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử gán trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử gọi hàm () trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử [] trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử truy cập thành viên lớp -> trong C++\n\t\t\t"]}}]}{"ten_noi_dung": "Nạp chồng toán tử ++ và -- trong C++", "ten_muc": "Nạp chồng toán tử ++ và -- trong C++", "noi_dung": "Các toán tử tăng (++) và toán tử giảm (--) là hai toán tử một ngôi quan trọng có sẵn trong C++.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử ++ và -- trong C++", "ten_muc": "Ví dụ Nạp chồng toán tử ++ và -- trong C++", "noi_dung": "Ví dụ sau minh họa cách nạp chồng toán tử tăng (++) với sự sử dụng của tiền tố cũng như hậu tố. Tương tự, bạn cũng có thể nạp chồng toán tử giảm (--) trong C++:\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử ++ và -- trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu-va-trong-c-_1603943222.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\nusing namespace std;\n\nclass ThoiGian\n{\nprivate:\n    int gio;             // tu 0 toi 23\n    int phut;           // tu 0 toi 59\npublic:\n    // phan khai bao cac constructor can thiet\n    ThoiGian() {\n        gio = 0;\n        phut = 0;\n    }\n    ThoiGian(int h, int m) {\n        gio = h;\n        phut = m;\n    }\n    // phuong thuc de hien thi thoi gian\n    void hienthiTG()\n    {\n        cout << \"Gio: \" << gio << \" Phut: \" << phut << endl;\n        cout << \"-----------------------\" << endl;\n    }\n    // nap chong toan tu ++ (tien to)\n    ThoiGian operator++ ()\n    {\n        ++phut;          // tang doi tuong nay\n        if (phut >= 60)\n        {\n            ++gio;\n            phut -= 60;\n        }\n        return ThoiGian(gio, phut);\n    }\n    // nap chong toan tu ++ (hau to)\n    ThoiGian operator++(int)\n    {\n        // luu giu gia tri ban dau\n        ThoiGian T(gio, phut);\n        // tang doi tuong nay\n        ++phut;\n        if (phut >= 60)\n        {\n            ++gio;\n            phut -= 60;\n        }\n        // tra ve gia tri\n        return T;\n    }\n};\n\nint main()\n{\n    ThoiGian T1(6, 59), T2(18, 30);\n\n    ++T1;                    // tang T1\n    T1.hienthiTG();        // hien thi T1\n    ++T1;                    // tang T1 mot lan lua\n    T1.hienthiTG();        // hien thi T1\n\n    T2++;                    // tang T2\n    T2.hienthiTG();        // hien thi T2\n    T2++;                    // tang T2 mot lan lua\n    T2.hienthiTG();        // hien thi T2\n    return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Toán tử trong C++", "ten_muc": "Toán tử số học trong C++", "noi_dung": "Bảng dưới đây mô tả các toán tử số học được hỗ trợ bởi ngôn ngữ C++. Giả sử biến A = 10 và biến B = 20:\n|table|\n", "media": [], "code": [], "table": [{"": {"Toán tử": ["+", "-", "*", "/", "%", "++", "--"], "Miêu tả": ["Thêm hai toán hạng", "Trừ giá trị toán hạng hai từ toán hạng đầu", "Nhân hai toán hạng", "Chia lấy phần nguyên hai toán hạng", "Chia lấy phần dư", "Lượng gia giá trị toán hạng thêm 1 đơn vị", "Lượng giảm giá trị toán hạng một đơn vị"], "Ví dụ": ["A + B sẽ cho kết quả là 30", "A - B sẽ cho kết quả là -10", "A * B sẽ cho kết quả là 200", "B / A sẽ cho kết quả là 2", "B % A sẽ cho kết quả là 0", "A++ sẽ cho kết quả là 11", "A-- sẽ cho kết quả là 9"]}}]}{"ten_noi_dung": "Toán tử trong C++", "ten_muc": "Toán tử quan hệ trong C++", "noi_dung": "Các toán tử quan hệ được sử dụng kiểm tra mối quan hệ giữa hai toán hạng. Kết quả của một biểu thức có dùng các toán tử quan hệ là những giá trị Boolean (logic “true” hoặc “false”). Các toán tử quan hệ được sử dụng trong các cấu trúc điều khiển.\nBảng dưới đây mô tả các toán tử quan hệ được hỗ trợ bởi ngôn ngữ C++. Giả sử biến A = 10 và biến B = 20:\n|table|\n", "media": [], "code": [], "table": [{"": {"Toán tử": ["==", "!=", ">", "<", ">=", "<="], "Miêu tả": ["Kiểm tra nếu 2 toán hạng bằng nhau hay không. Nếu bằng thì điều kiện là true.", "Kiểm tra 2 toán hạng có giá trị khác nhau hay không. Nếu không bằng thì điều kiện là true.", "Kiểm tra nếu toán hạng bên trái có giá trị lớn hơn toán hạng bên phải hay không. Nếu lớn hơn thì điều kiện là true.", "Kiểm tra nếu toán hạng bên trái nhỏ hơn toán hạng bên phải hay không. Nếu nhỏ hơn thì là true.", "Kiểm tra nếu toán hạng bên trái có giá trị lớn hơn hoặc bằng giá trị của toán hạng bên phải hay không. Nếu đúng là true.", "Kiểm tra nếu toán hạng bên trái có giá trị nhỏ hơn hoặc bằng toán hạng bên phải hay không. Nếu đúng là true."], "Ví dụ": ["(A == B) là không đúng.", "(A != B) là true.", "(A > B) là không đúng.", "(A < B) là true.", "(A >= B) là không đúng.", "(A <= B) là true."]}}]}{"ten_noi_dung": "Toán tử trong C++", "ten_muc": "Toán tử logic trong C++", "noi_dung": "Bảng dưới đây mô tả các toán tử logic được hỗ trợ bởi ngôn ngữ C++. Giả sử biến A = true (hoặc 1) và biến B = false (hoặc 0):\n|table|\n", "media": [], "code": [], "table": [{"": {"Toán tử": ["&&", "||", "!"], "Miêu tả": ["Được gọi là toán tử logic AND (và). Nếu cả hai toán tử đều có giá trị khác 0 thì điều kiện trở lên true.", "Được gọi là toán tử logic OR (hoặc). Nếu một trong hai toán tử khác 0, thì điều kiện là true.", "Được gọi là toán tử NOT (phủ định). Sử dụng để đảo ngược lại trạng thái logic của toán hạng đó. Nếu điều kiện toán hạng là true thì phủ định nó sẽ là false."], "Ví dụ": ["(A && B) là false.", "(A || B) là true.", "!(A && B) là true."]}}]}{"ten_noi_dung": "Toán tử trong C++", "ten_muc": "Toán tử bit trong C++", "noi_dung": "Các toán tử dạng bit cho phép chúng ta thao tác trên từng bit riêng biệt trong các kiểu dữ liệu nguyên thủy. Giả sử A = 60 (= 0011 1100) và B = 13 (= 0000 1101)\n|table|\n|table|\n", "media": [], "code": [], "table": [{"": {}}, {"": {"Toán tử": ["&", "|", "^", "~", "<<", ">>"], "Miêu tả": ["Toán tử AND (và) nhị phân sao chép một bit tới kết quả nếu nó tồn tại trong cả hai toán hạng.", "Toán tử OR (hoặc) nhị phân sao chép một bit tới kết quả nếu nó tồn tại trong một hoặc hai toán hạng.", "Toán tử XOR nhị phân sao chép bit mà nó chỉ tồn tại trong một toán hạng mà không phải cả hai.", "Toán tử đảo bit (đảo bit 1 thành bit 0 và ngược lại).", "Toán tử dịch trái. Giá trị toán hạng trái được dịch chuyển sang trái bởi số các bit được xác định bởi toán hạng bên phải.", "Toán tử dịch phải. Giá trị toán hạng trái được dịch chuyển sang phải bởi số các bit được xác định bởi toán hạng bên phải."], "Ví dụ": ["(A & B) sẽ cho kết quả là 12, tức là 0000 1100", "(A | B) sẽ cho kết quả là 61, tức là 0011 1101", "(A ^ B) sẽ cho kết quả là 49, tức là 0011 0001", "(~A ) sẽ cho kết quả là -61, tức là 1100 0011.", "A << 2 sẽ cho kết quả 240, tức là 1111 0000 (dịch sang trái hai bit)", "A >> 2 sẽ cho kết quả là 15, tức là 0000 1111 (dịch sang phải hai bit)"]}}]}{"ten_noi_dung": "Toán tử trong C++", "ten_muc": "Toán tử gán trong C++", "noi_dung": "Toán tử gán dùng để gán một giá trị vào một biến và có thể gán nhiều giá trị cho nhiều biến cùng một lúc.\n|table|\n", "media": [], "code": [], "table": [{"": {"Toán tử": ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", "&=", "^=", "|="], "Miêu tả": ["Toán tử gán đơn giản. Gán giá trị toán hạng bên phải cho toán hạng trái.", "Thêm giá trị toán hạng phải tới toán hạng trái và gán giá trị đó cho toán hạng trái.", "Trừ đi giá trị toán hạng phải từ toán hạng trái và gán giá trị này cho toán hạng trái.", "Nhân giá trị toán hạng phải với toán hạng trái và gán giá trị này cho toán hạng trái.", "Chia toán hạng trái cho toán hạng phải và gán giá trị này cho toán hạng trái.", "Lấy phần dư của phép chia toán hạng trái cho toán hạng phải và gán cho toán hạng trái.", "Dịch trái toán hạng trái sang số vị trí là giá trị toán hạng phải.", "Dịch phải toán hạng trái sang số vị trí là giá trị toán hạng phải.", "Phép AND bit", "Phép OR loại trừ bit", "Phép OR bit."], "Ví dụ": ["C = A + B sẽ gán giá trị của A + B vào trong C", "C += A tương đương với C = C + A", "C -= A tương đương với C = C - A", "C *= A tương đương với C = C * A", "C /= A tương đương với C = C / A", "C %= A tương đương với C = C % A", "C <<= 2 tương đương với C = C << 2", "C >>= 2 tương đương với C = C >> 2", "C &= 2 tương đương với C = C & 2", "C ^= 2 tương đương với C = C ^ 2", "C |= 2 tương đương với C = C | 2"]}}]}{"ten_noi_dung": "Toán tử trong C++", "ten_muc": "Toán tử hỗn hợp trong C++", "noi_dung": "Có một số toán tử hỗn hợp quan trọng là sizeof và ? : được hỗ trợ bởi ngôn ngữ C++.\n|table|\n", "media": [], "code": [], "table": [{"": {"Toán tử": ["sizeof()", "&", "*", "? :"], "Miêu tả": ["Trả lại kích cỡ của một biến", "Trả lại địa chỉ của một biến.", "Trỏ tới một biến.", "Biểu thức điều kiện"], "Ví dụ": ["sizeof(a), với a là integer, thì sẽ trả lại kết quả là 4.", "&a; sẽ cho địa chỉ thực sự của biến a.", "*a; sẽ trỏ tới biến a.", "Nếu điều kiện là true ? thì giá trị X : Nếu không thì giá trị Y"]}}]}