Các thành viên của Class được mặc định là public
A. Đúng
B. Sai
C.  
D.  
B. Sai
62568853ca04156772f95171
@
Hàm `Friend chỉ có quyền truy cập đối với các thành viên công khai của lớp..
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66541a9bed830e041bc
@
Một hàm khai báo ở kiểu public có thể được truy cập bởi những phương thức không phải là thành viên của class đó
A. Đúng
B. Sai
C.  
D.  
A. Đúng
6252a66d41a9bed830e04216
@
Các hàm friend có tính chất giao hoán
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66541a9bed830e041bb
@
New và delete là các toán tử
A. Đúng
B. Sai
C.  
D.  
A. Đúng
6253ed4b9a5e3f8c443f951b
@
Chúng ta có thể triển khai các lớp chung bằng cách sử dụng các khuôn mẫu (templates)
A. Đúng
B. Sai
C.  
D.  
A. Đúng
6252a66d41a9bed830e04210
@
Sử dụng quá tải toán tử có thể thiết kế ra các loại toán tử mới
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66b41a9bed830e04204
@
Kế thừa giúp biến một lớp chung thành một lớp cụ thể hơn.
A. Đúng
B. Sai
C.  
D.  
A. Đúng
6252a66d41a9bed830e04219
@
Một lớp cơ sở không bao giờ được sử dụng để tạo các đối tượng.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66d41a9bed830e0421a
@
Các lớp có thể được kế thừa một cách riêng tư.
A. Đúng
B. Sai
C.  
D.  
A. Đúng
6252a66d41a9bed830e0421b
@
Việc trả về các biến cục bộ từ một hàm trả về bằng tham chiếu là hợp lệ.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66041a9bed830e04188
@
Constructor có thể hoá như destructor ảo
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66241a9bed830e041a2
@
Trong C ++, người ta có thể định nghĩa một hàm trong một hàm khác.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66541a9bed830e041c0
@
“My Variable” là giá trị nhận dạng hợp lệ trong C ++.
A. Đúng
B. Sai
C.  
D.  
A. Đúng
6252a66141a9bed830e0418b
@
Trong C ++ người ta có thể lấy địa chỉ bộ nhớ của các biến và hàm.
A. Đúng
B. Sai
C.  
D.  
A. Đúng
6252a66241a9bed830e0419c
@
%= không phải là toán tử trong C++
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66e41a9bed830e04227
@
std::cout là lệnh nhập chuẩn.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66341a9bed830e041a8
@
Tất cả các hàm C ++ là đệ quy.
A. Đúng
B. Sai
C.  
D.  
A. Đúng
6252a66441a9bed830e041b1
@
Từ khóa 'break' chỉ được sử dụng trong câu lệnh switch..case.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66741a9bed830e041d1
@
Toán tử new trả về địa chỉ và kích thước của khối bộ nhớ mà nó cấp phát.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6253ed4b9a5e3f8c443f951b
@
Không cần thiết phải khởi tạo một tham chiếu đến đối tượng thực khi nó được khai báo.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66041a9bed830e04188
@
Có thể có một tham chiếu rỗng.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66041a9bed830e04188
@
Người ta có thể gán lại tham chiếu sau khi nó được khởi tạo.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66041a9bed830e04188
@
Người ta có thể áp dụng phép toán con trỏ với các biến tham chiếu.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66041a9bed830e04188
@
Một lớp là một đơn vị nhỏ nhất của lập trình hướng đối tượng.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66741a9bed830e041cf
@
Một hàm mẫu định nghĩa một hàm không có tham số, cho phép một chương trình gọi cùng một hàm với các kiểu đối số khác nhau.
A. Đúng
B. Sai
C.  
D.  
A. Đúng
6252a66d41a9bed830e04211
@
Destructor có thể nạp chồng?
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66341a9bed830e041a5
@
Biến Static không thể private.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66f41a9bed830e04232
@
Static member functions có thể dùng con trỏ this.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66f41a9bed830e04233
@
Người ta không thể sử dụng các phép liệt kê trong một lớp.
A. Đúng
B. Sai
C.  
D.  
A. Đúng
6252a66741a9bed830e041d7
@
Người ta không thể tạo một đối tượng của một lớp ảo.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66641a9bed830e041c8
@
Khi một ngoại lệ đã được ném ra, chương trình sẽ không thể quay trở lại điểm ném.
A. Đúng
B. Sai
C.  
D.  
A. Đúng
6252a67041a9bed830e0423b
@
Trong C++, chỉ một khối catch có thể xử lý tất cả các trường hợp ngoại lệ.
A. Đúng
B. Sai
C.  
D.  
A. Đúng
6252a67041a9bed830e0423c
@
Chỉ có thể có một khối catch trong chương trình
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a67041a9bed830e0423c
@
Khi một ngoại lệ nếu ném, nhưng không bị bắt, chương trình sẽ bỏ qua lỗi.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a67041a9bed830e0423b
@
Một lớp đối tượng được truyền cho một hàm template phải nạp chồng cho bất kỳ toán tử nào được sử dụng trên lớp đối tượng bởi khuôn mẫu.
A. Đúng
B. Sai
C.  
D.  
A. Đúng
6252a66d41a9bed830e04212
@
Trong định nghĩa mẫu hàm, không nhất thiết phải sử dụng từng tham số kiểu được khai báo trong tiền tố mẫu.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66d41a9bed830e04211
@
Có thể quá tải một mẫu hàm và một hàm thông thường (không phải mẫu).
A. Đúng
B. Sai
C.  
D.  
A. Đúng
6252a66b41a9bed830e04203
@
Một lớp mẫu có thể không được sử dụng làm lớp cơ sở.
A. Đúng
B. Sai
C.  
D.  
B. Sai
6252a66d41a9bed830e0421a
@
#include <iostream>
using namespace std;
int main()
{
  int a = 20;
  int &n = a;
  n = a++;
  a = n++;
  cout << a << "," << n << endl;
  system("pause");
}
Output của chương trình là gì?
A. 20,21
B. 20,20
C. 21, 22
D. 22,22
D. 22,22
6253ed4b9a5e3f8c443f951b

