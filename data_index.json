{"ten_noi_dung": "Nạp chồng toán tử gán trong C++", "ten_muc": "Nạp chồng toán tử gán trong C++", "noi_dung": "Bạn có thể nạp chồng toán tử gán (=) như khi bạn có thể với các toán tử khác trong C++ và nó có thể được sử dụng để tạo một đối tượng giống như copy constructor.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử gán trong C++", "ten_muc": "Ví dụ Nạp chồng toán tử gán trong C++", "noi_dung": "Ví dụ sau minh họa cách nạp chồng toán tử gán trong C++:\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử gán trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu-gan-trong-c-_1603944006.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\nusing namespace std;\n\nclass KhoangCach\n{\nprivate:\n    int met;\n    int centimet;\npublic:\n    // phan khai bao cac constructor can thiet\n    KhoangCach() {\n        met = 0;\n        centimet = 0;\n    }\n    KhoangCach(int m, int c) {\n        met = m;\n        centimet = c;\n    }\n    void operator=(const KhoangCach& K)\n    {\n        met = K.met;\n        centimet = K.centimet;\n    }\n    // phuong thuc de hien thi khoang cach\n    void hienthiKC()\n    {\n        cout << \"\\nDo dai bang m la: \" << met <<\n            \"\\nVa do dai bang cm la: \" << centimet << endl;\n    }\n\n};\nint main()\n{\n    KhoangCach K1(10, 16), K2(15, 50);\n    cout << \"Khoang cach dau tien: \";\n    K1.hienthiKC();\n    cout << \"\\n-------------------\\n\";\n    cout << \"Khoang cach thu hai:\";\n    K2.hienthiKC();\n    // su dung toan tu gan\n    K1 = K2;\n    cout << \"\\n-------------------\\n\";\n    cout << \"Khoang cach dau tien: \";\n    K1.hienthiKC();   return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử gọi hàm () trong C++", "ten_muc": "Nạp chồng toán tử gọi hàm () trong C++", "noi_dung": "Toán tử gọi hàm () trong C++ có thể được nạp chồng cho các đối tượng của kiểu lớp. Khi bạn nạp chồng (), bạn đang không tạo một cách mới để gọi một hàm. Đúng hơn là, bạn đang tạo một hàm toán tử mà có thể được truyền số tham số tùy ý.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử gọi hàm () trong C++", "ten_muc": "Ví dụ Nạp chồng toán tử gọi hàm () trong C++", "noi_dung": "Ví dụ sau minh họa cách nạp chồng toán tử gọi hàm () trong C++:\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử gọi hàm () trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu-goi-ham-trong-c-_1603945171.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\nusing namespace std;\n\nclass KhoangCach\n{\nprivate:\n    int met;\n    int centimet;\npublic:\n    // phan khai bao cac constructor can thiet\n    KhoangCach() {\n        met = 0;\n        centimet = 0;\n    }\n    KhoangCach(int m, int c) {\n        met = m;\n        centimet = c;\n    }\n    // nap chong toan tu goi ham ()\n    KhoangCach operator()(int x, int y, int z)\n    {\n        KhoangCach K;\n        // bay gio, dat phep tinh bat ky\n        K.met = x + y + 5;\n        K.centimet = y - z + 20;\n        return K;\n    }\n    // Phuong thuc de hien thi khoang cach\n    void hienthiKC()\n    {\n        cout << \"\\nDo dai bang m la: \" << met <<\n            \"\\nVa do dai bang cm la: \" << centimet << endl;\n    }\n\n};\n\nint main()\n{\n    KhoangCach K1(25, 40), K2;\n    cout << \"Khoang cach dau tien la: \";\n    K1.hienthiKC();   K2 = K1(15, 15, 15);\n    // trieu hoi toan tu ()\n    cout << \"\\n--------------------------\\n\";\n    cout << \"Khoang cach thu hai la: \";\n    K2.hienthiKC();   return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử Input/Output trong C++", "ten_muc": "Nạp chồng toán tử Input/Output trong C++", "noi_dung": "C++ là có thể input và output các kiểu dữ liệu có sẵn bởi sử dụng toán tử trích luồng >> và toán tử chèn luồng <<. Các toán tử trích luồng và chèn luồng cũng có thể được nạp chồng để thực hiện input và output cho các kiểu tự định nghĩa (user-defined).\nỞ đây, nó là quan trọng để tạo một hàm nạp chồng toán tử một friend của lớp, bởi vì nó sẽ được gọi mà không tạo một đối tượng.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử Input/Output trong C++", "ten_muc": "Ví dụ Nạp chồng toán tử Input/Output trong C++", "noi_dung": "Ví dụ sau giải thích cách nạp chồng toán tử trích luồng >> và toán tử chèn luồng << trong C++:.\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử Input/Output trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu-input-output-trong-c-_1603941994.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\nusing namespace std;\n\nclass KhoangCach\n{\nprivate:\n    int met;\n    int centimet;\npublic:\n    // phan khai bao cac constructor can thiet\n    KhoangCach() {\n        met = 0;\n        centimet = 0;\n    }\n    KhoangCach(int m, int c) {\n        met = m;\n        centimet = c;\n    }\n    friend ostream& operator<<(ostream& output,\n        const KhoangCach& K)\n    {\n        output << \"\\nDo dai bang m la: \" <<\n            K.met << \"\\nVa do dai bang cm la: \" << K.centimet;\n        return output;\n    }      friend istream& operator>>(istream& input, KhoangCach& K)\n    {\n        input >> K.met >> K.centimet;\n        return input;\n    }\n};\n\nint main()\n{\n    KhoangCach K1(20, 15), K2(15, 50), K3;\n    cout << \"Nhap gia tri cua doi tuong K3: \" << endl;\n    cin >> K3;\n    cout << \"Khoang cach dau tien: \" << K1 << endl;\n    cout << \"\\n==========================\\n\" << endl;\n    cout << \"Khoang cach thu hai: \" << K2 << endl;\n    cout << \"\\n==========================\\n\" << endl;\n    cout << \"Khoang cach thu ba: \" << K3 << endl;\n    return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử một ngôi trong C++", "ten_muc": "Nạp chồng toán tử một ngôi trong C++", "noi_dung": "Toán tử một ngôi (unary) trong C++ hoạt động trên một toán hạng đơn và dưới đây là một số ví dụ về toán tử một ngôi:\n\t\n\tNạp chồng toán tử tăng (++) và toán tử giảm (--) trong C++.\n\t\n\t\n\tToán tử một ngôi (-) trong C++\n\t\n\t\n\tToán tử logic phủ định (!) trong C++\n\t\nToán tử một ngôi hoạt động trên đối tượng mà chúng được gọi, và thường thì toán tử này xuất hiện bên trái đối tượng, dạng như: !obj, -obj, và ++obj, nhưng đôi khi chúng có thể sử dụng như là hậu tố giống như obj++ hoặc obj--.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử một ngôi trong C++", "ten_muc": "Ví dụ nạp chồng toán tử một ngôi trong C++", "noi_dung": "Ví dụ sau giải thích cách toán tử (-) có thể được nạp chồng với sự sử dụng tiền tố cũng như hậu tố.\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử một ngôi trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu-mot-ngoi-trong-c-_1603939218.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\nusing namespace std;\n\nclass KhoangCach\n{\nprivate:\n    int met;\n    int centimet;\npublic:\n    // khai bao cac constructor\n    KhoangCach() {\n        met = 0;\n        centimet = 0;\n    }\n    KhoangCach(int m, int c) {\n        met = m;\n        centimet = c;\n    }\n    // phuong thuc de hien thi khoang cach\n    void hienthiKC()\n    {\n        cout << \"Khoang cach bang m la: \" << met << endl;\n        cout << \"Khoang cach bang cm la: \" << centimet << endl;\n        cout << \"\\n\\n================================\\n\\n\" << endl;\n    }\n    // nap chong toan tu (-)\n    KhoangCach operator- ()\n    {\n        met = -met;\n        centimet = -centimet;\n        return KhoangCach(met, centimet);\n    }\n};\n\nint main()\n{\n    KhoangCach K1(10, 50), K2(-12, 15);\n    -K1;               // ap dung su phu dinh\n    K1.hienthiKC();    // hien thi K1\n    -K2;               // ap dung su phu dinh\n    K2.hienthiKC();    // hien thi K2\n    return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử nhị phân trong C++", "ten_muc": "Nạp chồng toán tử nhị phân trong C++", "noi_dung": "Các toán tử nhị phân trong C++ nhận hai tham số. Bạn sử dụng toán tử nhị phân khá thường xuyên, ví dụ như toán tử cộng (+), toán tử trừ (-) và toán tử chia (/).\nToán tử nhị phân (Binary Operator) sẽ hoạt động với 2 toán hạng. Một số ví dụ về toán tử nhị phân bao gồm toán tử số học (+, -, *, /, %), toán tử gán số học (+=, -+, *=, /+, %=) và toán tử quan hệ, ... . Nạp chồng toán tử nhị phân tương tự nạp chồng toán tử một ngôi, ngoại trừ toán tử nhị phân yêu cầu thêm tham số bổ sung.\nCú pháp nạp chồng toán tử nhị phân:\n|code|\nTrong đó toán tử là biểu tượng, biểu thị cho toán tử nhị phân.\n|code|\n", "media": [], "code": [{"": "\nToán tử toán tử (đối tượng 1, đối tượng 2);\n"}, {"": "\ntoán tử + (a, b);\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử nhị phân trong C++", "ten_muc": "Ví dụ nạp chồng toán tử nhị phân trong C++", "noi_dung": "Ví dụ sau giải thích cách toán tử cộng (+) có thể được nạp chồng trong C++. Tương tự, bạn có thể nạp chồng toán tử trừ (-) và toán tử chia (/).\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử nhị phân trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu-nhi-phan-trong-c-_1603940379.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\nusing namespace std;\n  \nclass Box\n{\npublic:\n    double tinhTheTich(void)\n    {\n        return chieudai * chieurong * chieucao;\n    }\n    void setChieuDai(double dai)\n    {\n        chieudai = dai;\n    }     \n    void setChieuRong(double rong)\n    {\n        chieurong = rong;\n    }\n    void setChieuCao(double cao)\n    {\n        chieucao = cao;\n    }\n  \n    // Nap chong toa tu + de cong hai doi tuong Box.\n    Box operator+(const Box& b)\n    {\n        Box box;\n        box.chieudai = this->chieudai + b.chieudai;\n        box.chieurong = this->chieurong + b.chieurong;\n        box.chieucao = this->chieucao + b.chieucao;\n        return box;\n    }\nprivate:\n    double chieudai;      // chieu dai cua mot box\n    double chieurong;     // Chieu rong cua mot box\n    double chieucao;      // Chieu cao cua mot box\n};\n// ham main cua chuong trinh\nint main()\n{\n    Box Box1;                // Khai bao Box1 la cua kieu Box\n    Box Box2;                // Khai bao Box2 la cua kieu Box\n    Box Box3;                // Khai bao Box3 la cua kieu Box\n    double thetich = 0.0;    // Luu giu the tich cua mot box tai day\n  \n    // thong tin chi tiet cua box 1\n    Box1.setChieuDai(3.0);\n    Box1.setChieuRong(4.0);\n    Box1.setChieuCao(5.0);\n  \n    // thong tin chi tiet cua box 2\n    Box2.setChieuDai(6.0);\n    Box2.setChieuRong(7.0);\n    Box2.setChieuCao(8.0);\n  \n    // the tich cua box 1\n    thetich = Box1.tinhTheTich();\n    cout << \"The tich cua Box1 la: \" << thetich << endl;\n  \n    // the tich cua box 2\n    thetich = Box2.tinhTheTich();\n    cout << \"The tich cua Box2 la: \" << thetich << endl;\n    // cong hai doi tuong nhu sau:\n    Box3 = Box1 + Box2;\n    // the tich cua box 3\n    thetich = Box3.tinhTheTich();\n    cout << \"The tich cua Box3 la: \" << thetich << endl;\n    return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử quan hệ trong C++", "ten_muc": "Nạp chồng toán tử quan hệ trong C++", "noi_dung": "Có nhiều toán tử quan hệ đa dạng được hỗ trợ bởi C++, ví dụ như: (<, >, <=, >=, ==, ...) mà có thể được sử dụng để so sánh các kiểu dữ liệu có sẵn trong C++.\nBạn có thể nạp chồng bất kỳ toán tử quan hệ nào, mà có thể được sử dụng để so sánh các đối tượng của một lớp.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử quan hệ trong C++", "ten_muc": "Ví dụ Nạp chồng toán tử quan hệ trong C++", "noi_dung": "Ví dụ sau giải thích cách toán tử < trong C++ có thể được nạp chồng và theo cách tương tự, bạn có thể nạp chồng các toán tử quan hệ khác trong C++:\n|code|\n              \n", "media": [], "code": [{"": "\n#include <iostream>\nusing namespace std;\n\nclass KhoangCach\n{\nprivate:\n    int met;\n    int centimet;\npublic:\n    // phan khai bao cac constructor can thiet\n    KhoangCach() {\n        met = 0;\n        centimet = 0;\n    }\n    KhoangCach(int m, int c) {\n        met = m;\n        centimet = c;\n    }      // nap chong toan tu <\n    bool operator <(const KhoangCach& k)\n    {\n        if (met < k.met)\n        {\n            return true;\n        }\n        if (met == k.met && centimet < k.centimet)\n        {\n            return true;\n        }\n        return false;\n    }\n};\n\nint main()\n{\n    KhoangCach K1(10, 15), K2(5, 20);\n\n    if (K1 < K2)\n    {\n        cout << \"K1 la ngan hon K2 \" << endl;\n    }\n    else\n    {\n        cout << \"K2 la ngan hon K1 \" << endl;\n    }\n    return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử subscript [] trong C++", "ten_muc": "Nạp chồng toán tử subscript [] trong C++", "noi_dung": "Toán tử subscript [] trong C++ thường được sử dụng để truy cập các phần tử mảng. Toán tử này có thể được nạp chồng để nâng cao tính năng đang tồn tại về mảng trong C++ (do vậy, có thể gọi là toán tử chỉ số mảng).\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử subscript [] trong C++", "ten_muc": "Ví dụ Nạp chồng toán tử subscript [] trong C++", "noi_dung": "Ví dụ sau minh họa cách nạp chồng toán tử subscript [] trong C++:\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nNạp chồng toán tử subscript [] trong C++\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử subscript [] trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu-subscript-trong-c-_1603946079.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\nusing namespace std;\nconst int SIZE = 15;\nclass ViDuMang\n{\nprivate:\n    int mang[SIZE];\npublic:\n    ViDuMang()\n    {\n        register int i;\n        for (i = 0; i < SIZE; i++)\n        {\n            mang[i] = i;\n        }\n    }\n    int& operator[](int i)\n    {\n        if (i > SIZE)\n        {\n            cout << \"\\n======================\\n\" << endl;\n            cout << \"Chi muc vuot gioi han!\" << endl;\n            // Tra ve phan tu dau tien.\n            return mang[0];\n        }\n        return mang[i];\n    }\n};\nint main()\n{\n    ViDuMang V;   cout << \"Gia tri cua V[3] la: \" << V[3] << endl;\n    cout << \"Gia tri cua V[6] la: \" << V[6] << endl;\n    cout << \"Gia tri cua V[16] la: \" << V[16] << endl;   return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử truy cập thành viên lớp (->) trong C++", "ten_muc": "Nạp chồng toán tử truy cập thành viên lớp (->) trong C++", "noi_dung": "Toán tử truy cập thành viên lớp (->) có thể được nạp chồng, nhưng nó khá là phức tạp. Nó được định nghĩa để cung cấp một kiểu lớp một hành vi \"pointer-like\". Toán tử -> phải là một hàm thành viên. Nếu được sử dụng, kiểu trả về của nó phải là một con trỏ hoặc một đối tượng của một lớp để bạn có thể áp dụng.\nToán tử -> thường được sử dụng kết hợp với toán tử * để triển khai \"smart pointer\". Những con trỏ này là các đối tượng mà vận hành như các con trỏ thông thường, ngoại trừ việc chúng thực hiện các tác vụ khi bạn truy cập một đối tượng thông qua chúng, ví dụ: xóa đối tượng tự động hoặc khi con trỏ bị hủy hoặc khi con trỏ được sử dụng để trỏ tới đối tượng khác.\nToán tử -> có thể được định nghĩa như là một toán tử hậu tố một ngôi.\n|code|\nCác đối tượng của lớp Ptr có thể được sử dụng để truy cập các thành viên của lớp X ở trên theo phương thức giống như cách các con trỏ được sử dụng. Ví dụ:\n|code|\nLệnh p->m được thông dịch thành (p.operator->())->m.\n", "media": [], "code": [{"": "\nclass Ptr{\n   //...\n   X * operator->();\n};\n"}, {"": "\nvoid f(Ptr p )\n{\n   p->m = 10 ; // la tuong tu (p.operator->())->m = 10\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử truy cập thành viên lớp (->) trong C++", "ten_muc": "Ví dụ Nạp chồng toán tử truy cập thành viên lớp (->) trong C++", "noi_dung": "Sử dụng cùng khái niệm trên, ví dụ sau sẽ giải thích cách một toán tử truy cập lớp -> trong C++ có thể được nạp chồng.\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nNạp chồng toán tử truy cập thành viên lớp (->) trong C++\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử truy cập thành viên lớp (->) trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\nCNhư vậy là chúng ta đã hoàn thành nội dung \"Nạp chồng toán tử trong C++ \". Để củng cố và nắm vững nội dung đã học, mời bạn cùng thử sức với \"Bộ Câu hỏi\nTrắc Nghiệm\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201112/images/nap-chong-toan-tu_1605173567.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// gia su co mot lop eLib sau.\nclass eLib {\n    static int i, j;\npublic:\n    // cac smart pointer de hien thi\n    void f() const { cout << i++ << endl; }\n    void g() const { cout << j++ << endl; }\n    void h() const { cout << \"--------\" << endl; }\n};// phan dinh nghia cac thanh vien Static:\n\nint eLib::i = 5;\nint eLib::j = 20;\n\n// Trien khai mot container cho lop tren\nclass VTContainer {\n    vector<eLib*> a;\npublic:\n    void add(eLib* vj)\n    {\n        a.push_back(vj);  // goi phuong thuc chuan cua vector.\n    }\n    friend class SmartPointer;\n};\n\n// trien khai smart pointer de truy cap thanh vien cua lop eLib.\nclass SmartPointer {\n    VTContainer vc;\n    int index;\npublic:\n    SmartPointer(VTContainer& vjc)\n    {\n        vc = vjc;\n        index = 0;\n    }\n    // tra ve gia tri de chi phan cuoi cua danh sach:\n    bool operator++() // phien ban toan tu ++ (tien to)\n    {\n        if (index >= vc.a.size()) return false;\n        if (vc.a[++index] == 0) return false;\n        return true;\n    }\n    bool operator++(int) // phien ban toan tu ++ (hau to)\n    {\n        return operator++();\n    }\n    // nap chong operator->\n    eLib* operator->() const\n    {\n        if (!vc.a[index])\n        {\n            cout << \"Gia tri 0!!\";\n            return (eLib*)0;\n        }\n        return vc.a[index];\n    }\n};int main() {\n    // so vong lap la 5 (ban thiet lap gia tri khac de xem ket qua)\n    const int sz = 5;\n    eLib o[sz];\n    VTContainer vc;\n    for (int i = 0; i < sz; i++)\n    {\n        vc.add(&o[i]);\n    }\n    SmartPointer sp(vc); // tao mot iterator\n    do {\n        sp->f(); // goi smart pointer\n        sp->g();\n        sp->h();\n    } while (sp++);\n    return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử và Nạp chồng hàm trong C++", "ten_muc": "Nạp chồng toán tử và Nạp chồng hàm trong C++", "noi_dung": "Nạp chồng hàm (function overloading) và Nạp chồng toán tử (operator overloading) trong C++ cho phép bạn xác định nhiều hơn một định nghĩa cho một tên hàm hoặc một toán tử trong cùng phạm vi (scope), được gọi tương ứng.\nMột khai báo nạp chồng là một khai báo mà đã được khai báo với cùng tên như một khai báo được khai báo trước đó trong cùng phạm vi, ngoại trừ rằng: cả hai khai báo có các tham số khác nhau và định nghĩa khác nhau.\nKhi bạn gọi một hàm nạp chồng hoặc một toán tử nạp chồng, thì compiler quyết định định nghĩa thích hợp nhất để sử dụng bằng việc so sánh các kiểu tham số bạn đã sử dụng để gọi hàm hoặc toán tử với các kiểu tham số đã được xác định trong các định nghĩa. Tiến trình lựa chọn hàm nạp chồng hoặc toán tử nạp chồng thích hợp nhất này được gọi là overload resolution - phân giải nạp chồng.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử và Nạp chồng hàm trong C++", "ten_muc": "Nạp chồng toán tử trong C++", "noi_dung": "Bạn có thể định nghĩa lại hoặc nạp chồng hầu hết các toán tử có sẵn trong C++. Vì thế, một lập trình viên có thể sử dụng các toán tử với kiểu tự định nghĩa (user-defined).\nNạp chồng toán tử trong C++ là các hàm với tên đặc biệt: Tên hàm là từ khóa operator theo sau là ký hiệu của toán tử đang được định nghĩa. Giống như bất kỳ hàm khác, một toán tử nạp chồng có một kiểu trả về và một danh sách tham số.\n|code|\nKhai báo toán tử + để cộng hai đối tượng Box và trả về đối tượng Box cuối cùng. Hầu hết toán tử nạp chồng có thể được định nghĩa dưới dạng: các hàm không có thành viên (non-member) hoặc các hàm thành viên lớp. Trong trường hợp trên, chúng ta định nghĩa hàm ở dạng non-member của một lớp, thì sau đó chúng ta phải truyền hai tham số cho mỗi toán hạng, như sau:\n|code|\nVí dụ sau minh họa khái niệm nạp chồng toán tử bởi sử dụng một hàm thành viên. Ở đây, một đối tượng được truyền như là một tham số mà các thuộc tính của nó sẽ được truy cập bởi sử dụng đối tượng này, đối tượng mà sẽ gọi toán tử này có thể được truy cập bởi sử dụng toán tử this, như sau:\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu2_1603936394.png", "Loai": "img"}], "code": [{"": "\nBox operator+(const Box&);\n"}, {"": "\nBox operator+(const Box&, const Box&);\n"}, {"": "\n#include <iostream>\nusing namespace std;\n\nclass Box\n{\npublic:\n    double tinhTheTich(void)\n    {\n        return chieudai * chieurong * chieucao;\n    }\n    void setChieuDai(double dai)\n    {\n        chieudai = dai;\n    }     \n    void setChieuRong(double rong)\n    {\n        chieurong = rong;\n    }\n    void setChieuCao(double cao)\n    {\n        chieucao = cao;\n    }\n\n    // Nap chong toa tu + de cong hai doi tuong Box.\n    Box operator+(const Box& b)\n    {\n        Box box;\n        box.chieudai = this->chieudai + b.chieudai;\n        box.chieurong = this->chieurong + b.chieurong;\n        box.chieucao = this->chieucao + b.chieucao;\n        return box;\n    }\nprivate:\n    double chieudai;      // chieu dai cua mot box\n    double chieurong;     // Chieu rong cua mot box\n    double chieucao;      // Chieu cao cua mot box\n};\n// ham main cua chuong trinh\nint main()\n{\n    Box Box1;                // Khai bao Box1 la cua kieu Box\n    Box Box2;                // Khai bao Box2 la cua kieu Box\n    Box Box3;                // Khai bao Box3 la cua kieu Box\n    double thetich = 0.0;    // Luu giu the tich cua mot box tai day\n\n    // thong tin chi tiet cua box 1\n    Box1.setChieuDai(3.0);\n    Box1.setChieuRong(4.0);\n    Box1.setChieuCao(5.0);\n\n    // thong tin chi tiet cua box 2\n    Box2.setChieuDai(6.0);\n    Box2.setChieuRong(7.0);\n    Box2.setChieuCao(8.0);\n\n    // the tich cua box 1\n    thetich = Box1.tinhTheTich();\n    cout << \"The tich cua Box1 la: \" << thetich << endl;\n\n    // the tich cua box 2\n    thetich = Box2.tinhTheTich();\n    cout << \"The tich cua Box2 la: \" << thetich << endl;\n    // cong hai doi tuong nhu sau:\n    Box3 = Box1 + Box2;\n    // the tich cua box 3\n    thetich = Box3.tinhTheTich();\n    cout << \"The tich cua Box3 la: \" << thetich << endl;\n    return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Nạp chồng toán tử và Nạp chồng hàm trong C++", "ten_muc": "Toán tử có thể nạp chồng và không thể nạp chồng trong C++", "noi_dung": "Bảng dưới liệt kê danh sách các toán tử có thể được nạp chồng trong C++:\n|table|\nCòn đây là danh sách các toán tử không thể được nạp chồng trong C++:\n|table|\n", "media": [], "code": [], "table": [{"": {"0": ["+", "&", "<", "<<", "+=", "|=", "->"], "1": ["-", "|", ">", ">>", "-=", "*=", "->*"], "2": ["*", "~", "<=", "==", "/=", "<<=", "new"], "3": ["/", "!", ">=", "!=", "%=", ">>=", "new []"], "4": ["%", ",", "++", "&&", "^=", "[]", "delete"], "5": ["^", "=", "--", "||", "&=", "()", "delete []"]}}, {"": {"0": ["::"], "1": [".*"], "2": ["."], "3": ["?:"]}}]}{"ten_noi_dung": "Nạp chồng toán tử và Nạp chồng hàm trong C++", "ten_muc": "Ví dụ về Nạp chồng toán tử trong C++", "noi_dung": "Dưới đây là các ví dụ đa dạng minh họa Nạp chồng toán tử trong C++, từ đó giúp bạn hiểu sâu hơn về khái niệm này. Bạn click vào link để thấy ví dụ:\n|table|\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử và Nạp chồng hàm trong C++. Nạp chồng (overloading) toán tử thường được người lập trình sử dụng rất nhiều trong lập trình hướng đối tượng. Vì vậy bạn đọc cần lưu ý. \n              \n", "media": [], "code": [], "table": [{"": {"STT": ["1", "2", "3", "4", "5", "6", "7", "8", "9"], "Toán tử và Ví dụ": ["\n\t\t\tNạp chồng toán tử một ngôi (unary) trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử nhị phân trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử quan hệ trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử Input/Output trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử ++ và -- trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử gán trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử gọi hàm () trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử [] trong C++\n\t\t\t", "\n\t\t\tNạp chồng toán tử truy cập thành viên lớp -> trong C++\n\t\t\t"]}}]}{"ten_noi_dung": "Nạp chồng toán tử ++ và -- trong C++", "ten_muc": "Nạp chồng toán tử ++ và -- trong C++", "noi_dung": "Các toán tử tăng (++) và toán tử giảm (--) là hai toán tử một ngôi quan trọng có sẵn trong C++.\n", "media": [], "code": [], "table": []}{"ten_noi_dung": "Nạp chồng toán tử ++ và -- trong C++", "ten_muc": "Ví dụ Nạp chồng toán tử ++ và -- trong C++", "noi_dung": "Ví dụ sau minh họa cách nạp chồng toán tử tăng (++) với sự sử dụng của tiền tố cũng như hậu tố. Tương tự, bạn cũng có thể nạp chồng toán tử giảm (--) trong C++:\n|code|\nBiên dịch và chạy chương trình C++ trên sẽ cho kết quả sau:\n|img|\nTrên đây là bài viết của eLib.VN về Nạp chồng toán tử ++ và -- trong C++. Hy vọng qua bài này bạn sẽ hiểu và vận dụng trong quá trình học tập và làm việc với C++. Chúc các bạn thành công!\n              \n", "media": [{"Link": "https://s.elib.vn/images/fckeditor/upload/2020/20201029/images/nap-chong-toan-tu-va-trong-c-_1603943222.png", "Loai": "img"}], "code": [{"": "\n#include <iostream>\nusing namespace std;\n\nclass ThoiGian\n{\nprivate:\n    int gio;             // tu 0 toi 23\n    int phut;           // tu 0 toi 59\npublic:\n    // phan khai bao cac constructor can thiet\n    ThoiGian() {\n        gio = 0;\n        phut = 0;\n    }\n    ThoiGian(int h, int m) {\n        gio = h;\n        phut = m;\n    }\n    // phuong thuc de hien thi thoi gian\n    void hienthiTG()\n    {\n        cout << \"Gio: \" << gio << \" Phut: \" << phut << endl;\n        cout << \"-----------------------\" << endl;\n    }\n    // nap chong toan tu ++ (tien to)\n    ThoiGian operator++ ()\n    {\n        ++phut;          // tang doi tuong nay\n        if (phut >= 60)\n        {\n            ++gio;\n            phut -= 60;\n        }\n        return ThoiGian(gio, phut);\n    }\n    // nap chong toan tu ++ (hau to)\n    ThoiGian operator++(int)\n    {\n        // luu giu gia tri ban dau\n        ThoiGian T(gio, phut);\n        // tang doi tuong nay\n        ++phut;\n        if (phut >= 60)\n        {\n            ++gio;\n            phut -= 60;\n        }\n        // tra ve gia tri\n        return T;\n    }\n};\n\nint main()\n{\n    ThoiGian T1(6, 59), T2(18, 30);\n\n    ++T1;                    // tang T1\n    T1.hienthiTG();        // hien thi T1\n    ++T1;                    // tang T1 mot lan lua\n    T1.hienthiTG();        // hien thi T1\n\n    T2++;                    // tang T2\n    T2.hienthiTG();        // hien thi T2\n    T2++;                    // tang T2 mot lan lua\n    T2.hienthiTG();        // hien thi T2\n    return 0;\n}\n"}], "table": []}{"ten_noi_dung": "Toán tử trong C++", "ten_muc": "Toán tử số học trong C++", "noi_dung": "Bảng dưới đây mô tả các toán tử số học được hỗ trợ bởi ngôn ngữ C++. Giả sử biến A = 10 và biến B = 20:\n|table|\n", "media": [], "code": [], "table": [{"": {"Toán tử": ["+", "-", "*", "/", "%", "++", "--"], "Miêu tả": ["Thêm hai toán hạng", "Trừ giá trị toán hạng hai từ toán hạng đầu", "Nhân hai toán hạng", "Chia lấy phần nguyên hai toán hạng", "Chia lấy phần dư", "Lượng gia giá trị toán hạng thêm 1 đơn vị", "Lượng giảm giá trị toán hạng một đơn vị"], "Ví dụ": ["A + B sẽ cho kết quả là 30", "A - B sẽ cho kết quả là -10", "A * B sẽ cho kết quả là 200", "B / A sẽ cho kết quả là 2", "B % A sẽ cho kết quả là 0", "A++ sẽ cho kết quả là 11", "A-- sẽ cho kết quả là 9"]}}]}{"ten_noi_dung": "Toán tử trong C++", "ten_muc": "Toán tử quan hệ trong C++", "noi_dung": "Các toán tử quan hệ được sử dụng kiểm tra mối quan hệ giữa hai toán hạng. Kết quả của một biểu thức có dùng các toán tử quan hệ là những giá trị Boolean (logic “true” hoặc “false”). Các toán tử quan hệ được sử dụng trong các cấu trúc điều khiển.\nBảng dưới đây mô tả các toán tử quan hệ được hỗ trợ bởi ngôn ngữ C++. Giả sử biến A = 10 và biến B = 20:\n|table|\n", "media": [], "code": [], "table": [{"": {"Toán tử": ["==", "!=", ">", "<", ">=", "<="], "Miêu tả": ["Kiểm tra nếu 2 toán hạng bằng nhau hay không. Nếu bằng thì điều kiện là true.", "Kiểm tra 2 toán hạng có giá trị khác nhau hay không. Nếu không bằng thì điều kiện là true.", "Kiểm tra nếu toán hạng bên trái có giá trị lớn hơn toán hạng bên phải hay không. Nếu lớn hơn thì điều kiện là true.", "Kiểm tra nếu toán hạng bên trái nhỏ hơn toán hạng bên phải hay không. Nếu nhỏ hơn thì là true.", "Kiểm tra nếu toán hạng bên trái có giá trị lớn hơn hoặc bằng giá trị của toán hạng bên phải hay không. Nếu đúng là true.", "Kiểm tra nếu toán hạng bên trái có giá trị nhỏ hơn hoặc bằng toán hạng bên phải hay không. Nếu đúng là true."], "Ví dụ": ["(A == B) là không đúng.", "(A != B) là true.", "(A > B) là không đúng.", "(A < B) là true.", "(A >= B) là không đúng.", "(A <= B) là true."]}}]}{"ten_noi_dung": "Toán tử trong C++", "ten_muc": "Toán tử logic trong C++", "noi_dung": "Bảng dưới đây mô tả các toán tử logic được hỗ trợ bởi ngôn ngữ C++. Giả sử biến A = true (hoặc 1) và biến B = false (hoặc 0):\n|table|\n", "media": [], "code": [], "table": [{"": {"Toán tử": ["&&", "||", "!"], "Miêu tả": ["Được gọi là toán tử logic AND (và). Nếu cả hai toán tử đều có giá trị khác 0 thì điều kiện trở lên true.", "Được gọi là toán tử logic OR (hoặc). Nếu một trong hai toán tử khác 0, thì điều kiện là true.", "Được gọi là toán tử NOT (phủ định). Sử dụng để đảo ngược lại trạng thái logic của toán hạng đó. Nếu điều kiện toán hạng là true thì phủ định nó sẽ là false."], "Ví dụ": ["(A && B) là false.", "(A || B) là true.", "!(A && B) là true."]}}]}{"ten_noi_dung": "Toán tử trong C++", "ten_muc": "Toán tử bit trong C++", "noi_dung": "Các toán tử dạng bit cho phép chúng ta thao tác trên từng bit riêng biệt trong các kiểu dữ liệu nguyên thủy. Giả sử A = 60 (= 0011 1100) và B = 13 (= 0000 1101)\n|table|\n|table|\n", "media": [], "code": [], "table": [{"": {}}, {"": {"Toán tử": ["&", "|", "^", "~", "<<", ">>"], "Miêu tả": ["Toán tử AND (và) nhị phân sao chép một bit tới kết quả nếu nó tồn tại trong cả hai toán hạng.", "Toán tử OR (hoặc) nhị phân sao chép một bit tới kết quả nếu nó tồn tại trong một hoặc hai toán hạng.", "Toán tử XOR nhị phân sao chép bit mà nó chỉ tồn tại trong một toán hạng mà không phải cả hai.", "Toán tử đảo bit (đảo bit 1 thành bit 0 và ngược lại).", "Toán tử dịch trái. Giá trị toán hạng trái được dịch chuyển sang trái bởi số các bit được xác định bởi toán hạng bên phải.", "Toán tử dịch phải. Giá trị toán hạng trái được dịch chuyển sang phải bởi số các bit được xác định bởi toán hạng bên phải."], "Ví dụ": ["(A & B) sẽ cho kết quả là 12, tức là 0000 1100", "(A | B) sẽ cho kết quả là 61, tức là 0011 1101", "(A ^ B) sẽ cho kết quả là 49, tức là 0011 0001", "(~A ) sẽ cho kết quả là -61, tức là 1100 0011.", "A << 2 sẽ cho kết quả 240, tức là 1111 0000 (dịch sang trái hai bit)", "A >> 2 sẽ cho kết quả là 15, tức là 0000 1111 (dịch sang phải hai bit)"]}}]}{"ten_noi_dung": "Toán tử trong C++", "ten_muc": "Toán tử gán trong C++", "noi_dung": "Toán tử gán dùng để gán một giá trị vào một biến và có thể gán nhiều giá trị cho nhiều biến cùng một lúc.\n|table|\n", "media": [], "code": [], "table": [{"": {"Toán tử": ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", "&=", "^=", "|="], "Miêu tả": ["Toán tử gán đơn giản. Gán giá trị toán hạng bên phải cho toán hạng trái.", "Thêm giá trị toán hạng phải tới toán hạng trái và gán giá trị đó cho toán hạng trái.", "Trừ đi giá trị toán hạng phải từ toán hạng trái và gán giá trị này cho toán hạng trái.", "Nhân giá trị toán hạng phải với toán hạng trái và gán giá trị này cho toán hạng trái.", "Chia toán hạng trái cho toán hạng phải và gán giá trị này cho toán hạng trái.", "Lấy phần dư của phép chia toán hạng trái cho toán hạng phải và gán cho toán hạng trái.", "Dịch trái toán hạng trái sang số vị trí là giá trị toán hạng phải.", "Dịch phải toán hạng trái sang số vị trí là giá trị toán hạng phải.", "Phép AND bit", "Phép OR loại trừ bit", "Phép OR bit."], "Ví dụ": ["C = A + B sẽ gán giá trị của A + B vào trong C", "C += A tương đương với C = C + A", "C -= A tương đương với C = C - A", "C *= A tương đương với C = C * A", "C /= A tương đương với C = C / A", "C %= A tương đương với C = C % A", "C <<= 2 tương đương với C = C << 2", "C >>= 2 tương đương với C = C >> 2", "C &= 2 tương đương với C = C & 2", "C ^= 2 tương đương với C = C ^ 2", "C |= 2 tương đương với C = C | 2"]}}]}{"ten_noi_dung": "Toán tử trong C++", "ten_muc": "Toán tử hỗn hợp trong C++", "noi_dung": "Có một số toán tử hỗn hợp quan trọng là sizeof và ? : được hỗ trợ bởi ngôn ngữ C++.\n|table|\n", "media": [], "code": [], "table": [{"": {"Toán tử": ["sizeof()", "&", "*", "? :"], "Miêu tả": ["Trả lại kích cỡ của một biến", "Trả lại địa chỉ của một biến.", "Trỏ tới một biến.", "Biểu thức điều kiện"], "Ví dụ": ["sizeof(a), với a là integer, thì sẽ trả lại kết quả là 4.", "&a; sẽ cho địa chỉ thực sự của biến a.", "*a; sẽ trỏ tới biến a.", "Nếu điều kiện là true ? thì giá trị X : Nếu không thì giá trị Y"]}}]}